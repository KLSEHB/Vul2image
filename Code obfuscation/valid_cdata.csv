idx,processed_func,target
14077,"void function()
{
short data;
data = 0;
if(globalTrue)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
4197,"void function()
{
int i;
int * data;
data = NULL;
for(i = 0; i < 1; i++)
{
data = (int *)malloc(10);
if (data == NULL) {exit(-1);}
}
{
int source[10] = {0};
memmove(data, source, 10*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",0
16374,"void function()
{
int data;
data = -1;
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
18617,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
}
}
",1
7810,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_FIVE==5)
{
badVaSinkB(data, data);
}
}
",0
8987,"void function()
{
wchar_t * data;
data = NULL;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
}
{
wchar_t source[10+1] = SRC_STRING;
memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
free(data);
}
}
",1
8749,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncat(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
12473,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
goto source;
source:
wcscpy(data, L""fixedstringtest"");
goto sink;
sink:
goodG2BVaSinkB(data, data);
}
",1
23098,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(GLOBAL_CONST_TRUE)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
}
}
",1
6794,"void function()
{
twoIntsStruct * data;
data = NULL;
switch(6)
{
case 6:
data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
free(data);
}
}
",0
15455,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncat(data, source, 100);
printLine(data);
}
}
",1
16210,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
{
wchar_t * data = *dataPtr1;
data = dataGoodBuffer;
data[0] = L'\0'; 
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0'; 
printWLine(data);
}
}
}
",1
15661,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
if(globalReturnsTrue())
{
data = dataGoodBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memmove(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
11116,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
while(1)
{
strcpy(data, ""fixedstringtest"");
break;
}
while(1)
{
goodG2BVaSinkB(data, data);
break;
}
}
",1
11479,"void function()
{
short data;
CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_34_unionType myUnion;
data = 0;
data = 100-1;
myUnion.unionFirst = data;
{
short data = myUnion.unionSecond;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",1
4124,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
if(5==5)
{
data = dataBadBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
1218,"void function()
{
short data;
data = 0;
if(staticTrue)
{
fscanf (stdin, ""%hd"", &data);
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
1703,"void function()
{
int data;
data = -1;
if(5==5)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(5==5)
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
free(buffer);
}
}
}
",0
11741,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
while(1)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
break;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscat(data, source);
printWLine(data);
}
}
",1
2161,"void function()
{
int data;
data = -1;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalTrue)
{
{
int buffer[10] = { 0 };
if (data < 10)
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is too big."");
}
}
}
}
",0
8059,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(staticTrue)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",0
15157,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
}
}
",1
18834,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(5==5)
{
data = dataGoodBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memcpy(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
2136,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(GLOBAL_CONST_FIVE==5)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncat(data, source, 100);
printWLine(data);
}
}
",0
5755,"void function()
{
int j;
for(j = 0; j < 1; j++)
{
{
char src[150], dest[100];
int i;
memset(src, 'A', 149);
src[149] = '\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
printLine(dest);
}
}
}
",0
1519,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(5==5)
{
data = dataBuffer - 8;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
strncpy(dest, data, strlen(dest));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
13941,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
char dest[100*2];
memset(dest, 'C', 100*2-1); 
dest[100*2-1] = '\0'; 
strcpy(dest, data);
printLine(dest);
}
}
",1
365,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_TRUE)
{
badVaSinkB(data, data);
}
}
",0
15708,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
wcscpy(data, L""fixedstringtest"");
}
if(STATIC_CONST_FIVE==5)
{
goodG2B2VaSinkB(data, data);
}
}
",1
4741,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
}
}
",0
17771,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticTrue)
{
strcpy(data, ""fixedstringtest"");
}
if(staticTrue)
{
goodG2B2VaSinkB(data, data);
}
}
",1
20348,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
SNPRINTF(dest, strlen(data), ""%s"", data);
printLine(data);
}
}
",1
15907,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",1
18726,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(globalTrue)
{
wprintf(data);
}
}
",1
3614,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(staticTrue)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strncpy(data, source, strlen(source) + 1);
printLine(data);
}
}
",0
16771,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",1
4344,"void function()
{
int j;
for(j = 0; j < 1; j++)
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid->voidSecond);
memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid->charFirst);
printWLine((wchar_t *)structCharVoid->voidSecond);
}
}
}
",0
14748,"void function()
{
int data;
data = -1;
if(5==5)
{
fscanf(stdin, ""%d"", &data);
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
6140,"void function()
{
int data;
data = -1;
if(globalReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
20405,"void function()
{
wchar_t * data;
data = NULL;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
3710,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
data = dataBadBuffer;
{
char * dataCopy = data;
char * data = dataCopy;
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memmove(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
}
",0
20520,"void function()
{
int data;
data = -1;
if(globalReturnsTrue())
{
fscanf(stdin, ""%d"", &data);
}
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
1963,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(GLOBAL_CONST_FIVE==5)
{
data = dataBuffer - 8;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",0
15052,"void function()
{
wchar_t * data;
data = NULL;
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
}
{
wchar_t source[10+1] = SRC_STRING;
memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
free(data);
}
}
",1
14789,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(STATIC_CONST_TRUE)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = strlen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printLine(data);
}
}
",1
10197,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(STATIC_CONST_TRUE)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
memcpy(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
12400,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_TRUE)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
14992,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
18884,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
wcscpy(data, L""fixedstringtest"");
}
if(GLOBAL_CONST_TRUE)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
}
}
",1
7367,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(staticFive==5)
{
data = dataBuffer - 8;
}
{
wchar_t dest[100*2];
wmemset(dest, L'C', 100*2-1); 
dest[100*2-1] = L'\0'; 
wcscpy(dest, data);
printWLine(dest);
}
}
",0
9076,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
2319,"void function()
{
void * data;
void * *dataPtr1 = &data;
void * *dataPtr2 = &data;
data = NULL;
{
void * data = *dataPtr1;
data = (void *)WIDE_STRING;
*dataPtr1 = data;
}
{
void * data = *dataPtr2;
{
size_t dataLen = strlen((char *)data);
void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
(void)wcscpy(dest, data);
printLine((char *)dest);
}
}
}
",0
2148,"void function()
{
short data;
data = 0;
if(STATIC_CONST_TRUE)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = (short)atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
15103,"void function()
{
short data;
data = 0;
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
data = 100-1;
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
7825,"void function()
{
int data;
data = -1;
goto source;
source:
fscanf(stdin, ""%d"", &data);
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
14781,"void function()
{
wchar_t * data;
data = NULL;
if(globalTrue)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memmove(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
19967,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
strcpy(data, ""fixedstringtest"");
break;
}
switch(7)
{
case 7:
goodG2B1VaSinkB(data, data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
2488,"void function()
{
int data;
data = -1;
data = RAND32();
{
int dataCopy = data;
int data = dataCopy;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",0
3094,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
}
}
",0
3604,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalReturnsTrue())
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(globalReturnsTrue())
{
badVaSinkB(data, data);
}
}
",0
9893,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalFive==5)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(globalFive==5)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
41,"void function()
{
int data;
int *dataPtr1 = &data;
int *dataPtr2 = &data;
data = -1;
{
int data = *dataPtr1;
fscanf(stdin, ""%d"", &data);
*dataPtr1 = data;
}
{
int data = *dataPtr2;
{
int i;
int buffer[10] = { 0 };
if (data < 10)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
}
}
}
",0
3150,"void function()
{
int * data;
data = NULL;
if(globalTrue)
{
data = (int *)malloc(50*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[100] = {0}; 
memmove(data, source, 100*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",0
18278,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
goto source;
source:
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
{
char dest[50] = """";
strcpy(dest, data);
printLine(data);
}
}
",1
6808,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(globalReturnsTrue())
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = wcslen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printWLine(data);
}
}
",0
12056,"void function()
{
char * data;
data = NULL;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
}
}
",1
18800,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
2819,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(GLOBAL_CONST_TRUE)
{
badVaSinkB(data, data);
}
}
",0
23086,"void function()
{
wchar_t * data;
CWE127_Buffer_Underread__wchar_t_alloca_cpy_34_unionType myUnion;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t dest[100*2];
wmemset(dest, L'C', 100*2-1); 
dest[100*2-1] = L'\0'; 
wcscpy(dest, data);
printWLine(dest);
}
}
}
",1
7276,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
10890,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(STATIC_CONST_FIVE==5)
{
goodG2B1VaSinkB(data, data);
}
}
",1
16199,"void function()
{
int data;
data = -1;
fscanf(stdin, ""%d"", &data);
{
int dataCopy = data;
int data = dataCopy;
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
free(buffer);
}
}
}
",1
13331,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(staticReturnsTrue())
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0';
printWLine(data);
}
}
",1
9351,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(globalReturnsTrue())
{
data = dataGoodBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memmove(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
12466,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
fwprintf(stdout, L""%s\n"", data);
}
",1
20273,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(globalTrue)
{
wprintf(L""%s\n"", data);
}
}
",1
13032,"void function()
{
int data;
data = -1;
if(staticTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticTrue)
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
13970,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
{
size_t i;
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
22195,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticTrue)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
1223,"void function()
{
wchar_t * data;
data = NULL;
while(1)
{
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
break;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
",0
14465,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(1)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
1924,"void function()
{
wchar_t * data;
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_ncat_34_unionType myUnion;
data = NULL;
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncat(data, source, 100);
printWLine(data);
free(data);
}
}
}
",0
13467,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
goto source;
source:
data = dataGoodBuffer;
data[0] = '\0'; 
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcat(data, source);
printLine(data);
}
}
",1
2366,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(STATIC_CONST_TRUE)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",0
2168,"void function()
{
int data;
data = -1;
goto source;
source:
fscanf(stdin, ""%d"", &data);
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
22559,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t dest[50] = L"""";
wcsncpy(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
}
",1
10967,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(GLOBAL_CONST_TRUE)
{
data = dataBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
12962,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
21073,"void function()
{
void * data;
data = NULL;
if(STATIC_CONST_FIVE==5)
{
data = (void *)WIDE_STRING;
}
if(STATIC_CONST_FIVE==5)
{
{
size_t dataLen = wcslen((wchar_t *)data);
void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
(void)wcscpy(dest, data);
printWLine((wchar_t *)dest);
}
}
}
",1
15347,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_TRUE)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
23034,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncpy(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
4261,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
badVaSinkB(data, data);
}
}
",0
3891,"void function()
{
char * data;
CWE124_Buffer_Underwrite__malloc_char_ncpy_34_unionType myUnion;
data = NULL;
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
}
",0
3145,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
4637,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
{
wchar_t dest[50] = L"""";
size_t i, dataLen;
dataLen = wcslen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",0
10026,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
13030,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(STATIC_CONST_TRUE)
{
goodG2B1VaSinkB(data, data);
}
}
",1
22338,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
{
char * data = *dataPtr1;
data = dataBuffer;
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
}
",1
62,"void function()
{
char * data;
data = NULL;
if(staticTrue)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
",0
427,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
{
char * dataCopy = data;
char * data = dataCopy;
badVaSink(data, data);
}
}
",0
5116,"void function()
{
char * data;
data = NULL;
if(staticTrue)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
strncpy(dest, data, strlen(dest));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
7227,"void function()
{
short data;
data = 0;
if(GLOBAL_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
",0
393,"void function()
{
wchar_t * data;
CWE122_Heap_Based_Buffer_Overflow__c_dest_wchar_t_cat_34_unionType myUnion;
data = NULL;
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscat(data, source);
printWLine(data);
free(data);
}
}
}
",0
3836,"void function()
{
short data;
data = 0;
if(1)
{
data = (short)RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
18201,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalFive==5)
{
data = dataBuffer;
}
{
size_t i;
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
21087,"void function()
{
int * data;
data = NULL;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (int *)malloc(10*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[10] = {0};
memcpy(data, source, 10*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",1
13452,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
printf(""%s\n"", data);
}
}
",1
14316,"void function()
{
int data;
data = -1;
data = 100-1;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
15664,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
11924,"void function()
{
int data;
data = -1;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive==5)
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
15955,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
while(1)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
break;
}
while(1)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
break;
}
}
",1
13961,"void function()
{
short data;
data = 0;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
12933,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
}
}
",1
10700,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
{
char * data = *dataPtr1;
data = dataGoodBuffer;
data[0] = '\0'; 
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
}
",1
16770,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
",1
15538,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
12984,"void function()
{
wchar_t * data;
data = NULL;
if(STATIC_CONST_FIVE==5)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",1
16875,"void function()
{
int data;
data = -1;
if(STATIC_CONST_TRUE)
{
fscanf(stdin, ""%d"", &data);
}
if(STATIC_CONST_TRUE)
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
free(buffer);
}
}
}
",1
5859,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticFive==5)
{
data = dataBuffer - 8;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
13411,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
while(1)
{
data = dataBuffer;
break;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",1
15536,"void function()
{
int * data;
data = NULL;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = (int *)malloc(100*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[100] = {0}; 
memcpy(data, source, 100*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",1
5218,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(GLOBAL_CONST_FIVE==5)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",0
17304,"void function()
{
wchar_t * data;
data = NULL;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscat(data, source);
printWLine(data);
free(data);
}
}
",1
14382,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(STATIC_CONST_FIVE==5)
{
goodG2B1VaSinkB(data, data);
}
}
",1
15866,"void function()
{
int * data;
int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
int source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
}
}
}
",1
20343,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive==5)
{
goodB2G2VaSinkG(data, data);
}
}
",1
8014,"void function()
{
if(globalFive==5)
{
{
char src[150], dest[100];
int i;
memset(src, 'A', 149);
src[149] = '\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
printLine(dest);
}
}
}
",0
3052,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",0
6950,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
goto source;
source:
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
{
wchar_t dest[50] = L"""";
size_t i, dataLen;
dataLen = wcslen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",0
6213,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_TRUE)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
2484,"void function()
{
wchar_t * data;
data = NULL;
if(staticFive==5)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
",0
19518,"void function()
{
int data;
data = -1;
while(1)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
break;
}
while(1)
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
break;
}
}
",1
13314,"void function()
{
if(STATIC_CONST_FIVE==5)
{
{
char src[150], dest[100];
int i;
memset(src, 'A', 149);
src[149] = '\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
dest[99] = '\0'; 
printLine(dest);
}
}
}
",1
4551,"void function()
{
wchar_t * data;
data = NULL;
if(1)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0';
printWLine(data);
}
}
",0
3491,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(1)
{
data = dataBuffer - 8;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memmove(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
18741,"void function()
{
short data;
data = 0;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
1927,"void function()
{
wchar_t * data;
data = NULL;
if(staticTrue)
{
data = (wchar_t *)malloc(10*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
}
{
wchar_t source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = wcslen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printWLine(data);
free(data);
}
}
",0
20309,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
free(data);
}
}
",1
1096,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
goto source;
source:
data = dataBadBuffer;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memmove(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
5662,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100] = """";
data = dataBuffer;
{
char * data = *dataPtr1;
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
fprintf(stdout, data);
}
}
",0
8175,"void function()
{
wchar_t * data;
data = NULL;
if(globalTrue)
{
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
",0
11171,"void function()
{
int * data;
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int_loop_34_unionType myUnion;
data = NULL;
data = (int *)malloc(100*sizeof(int));
if (data == NULL) {exit(-1);}
myUnion.unionFirst = data;
{
int * data = myUnion.unionSecond;
{
int source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
free(data);
}
}
}
}
",1
18742,"void function()
{
twoIntsStruct * data;
data = NULL;
if(globalTrue)
{
data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memcpy(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
free(data);
}
}
",1
16045,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(5==5)
{
strcpy(data, ""fixedstringtest"");
}
if(5==5)
{
goodG2B2VaSinkB(data, data);
}
}
",1
18054,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(globalReturnsTrue())
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
7981,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
while(1)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
break;
}
while(1)
{
badVaSinkB(data, data);
break;
}
}
",0
4293,"void function()
{
int * data;
int dataBadBuffer[50];
int dataGoodBuffer[100];
if(staticFive==5)
{
data = dataBadBuffer;
}
{
int source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
}
}
}
",0
15662,"void function()
{
short data;
data = 0;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
9233,"void function()
{
char * data;
data = NULL;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
",1
517,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(globalReturnsTrue())
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
}
}
",0
8839,"void function()
{
int * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
data = (int *)malloc(10*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[10] = {0};
memcpy(data, source, 10*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",1
2460,"void function()
{
short data;
data = 0;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
14227,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(globalTrue)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = wcslen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printWLine(data);
}
}
",1
20649,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
goodB2G2VaSinkG(data, data);
}
}
",1
18912,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",1
12928,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive==5)
{
goodB2G2VaSinkG(data, data);
}
}
",1
13656,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wprintf(L""%s\n"", data);
}
}
",1
12131,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalTrue)
{
wcscpy(data, L""fixedstringtest"");
}
if(globalTrue)
{
goodG2B2VaSinkB(data, data);
}
}
",1
17863,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(STATIC_CONST_TRUE)
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
2646,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsTrue())
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(staticReturnsTrue())
{
badVaSinkB(data, data);
}
}
",0
17253,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(STATIC_CONST_FIVE==5)
{
data = dataBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memcpy(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
1131,"void function()
{
wchar_t * data;
data = NULL;
if(globalTrue)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
23097,"void function()
{
wchar_t * data;
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memcpy_34_unionType myUnion;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataGoodBuffer;
data[0] = L'\0'; 
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
}
",1
3277,"void function()
{
int data;
data = -1;
if(globalFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalFive==5)
{
{
int buffer[10] = { 0 };
if (data < 10)
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is too big."");
}
}
}
}
",0
6458,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
{
char * data = *dataPtr1;
data = dataBadBuffer;
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memcpy(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
}
",0
4731,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(5==5)
{
data = dataBuffer - 8;
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",0
20476,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcpy(dest, data);
printLine(data);
free(data);
}
}
",1
9010,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
goodB2GVaSink(data, data);
}
",1
16905,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalReturnsTrue())
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
4097,"void function()
{
int * data;
data = NULL;
if(STATIC_CONST_FIVE==5)
{
data = (int *)ALLOCA(10);
}
{
int source[10] = {0};
memmove(data, source, 10*sizeof(int));
printIntLine(data[0]);
}
}
",0
9291,"void function()
{
int * data;
data = NULL;
if(staticTrue)
{
data = (int *)ALLOCA(10*sizeof(int));
}
{
int source[10] = {0};
size_t i;
for (i = 0; i < 10; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
}
}
",1
776,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(globalFive==5)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
}
}
",0
22577,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(globalTrue)
{
goodB2G2VaSinkG(data, data);
}
}
",1
11064,"void function()
{
wchar_t * data;
data = NULL;
if(GLOBAL_CONST_FIVE==5)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
size_t i;
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
21870,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(STATIC_CONST_TRUE)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
SNPRINTF(data, 100, L""%s"", source);
printWLine(data);
}
}
",1
44,"void function()
{
void * data;
void * *dataPtr1 = &data;
void * *dataPtr2 = &data;
data = NULL;
{
void * data = *dataPtr1;
{
wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
if (dataBadBuffer == NULL) {exit(-1);}
wmemset(dataBadBuffer, L'A', 50-1);
dataBadBuffer[50-1] = L'\0';
data = (void *)dataBadBuffer;
}
*dataPtr1 = data;
}
{
void * data = *dataPtr2;
{
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
if (dest == NULL) {exit(-1);}
(void)wcscpy(dest, data);
printLine((char *)dest);
free(dest);
}
}
}
",0
23101,"void function()
{
int h,j;
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
for(h = 0; h < 1; h++)
{
wcscpy(data, L""fixedstringtest"");
}
for(j = 0; j < 1; j++)
{
goodG2BVaSinkB(data, data);
}
}
",1
10643,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
goodB2GVaSink(data, data);
}
}
",1
14673,"void function()
{
int * data;
int dataBadBuffer[50];
int dataGoodBuffer[100];
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
data = dataGoodBuffer;
break;
}
{
int source[100] = {0}; 
memmove(data, source, 100*sizeof(int));
printIntLine(data[0]);
}
}
",1
8505,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
break;
}
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
}
}
",1
3774,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
switch(6)
{
case 6:
data = dataBuffer - 8;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memcpy(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
18098,"void function()
{
twoIntsStruct * data;
twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memcpy(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",1
17339,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
9546,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsTrue())
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
18325,"void function()
{
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t src[150], dest[100];
int i;
wmemset(src, L'A', 149);
src[149] = L'\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
dest[99] = L'\0'; 
printWLine(dest);
}
}
}
",1
20598,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
5158,"void function()
{
int data;
data = -1;
if(globalTrue)
{
data = RAND32();
}
if(globalTrue)
{
{
int i;
int buffer[10] = { 0 };
if (data < 10)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
}
}
}
",0
16894,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(STATIC_CONST_FIVE==5)
{
data = dataBuffer;
}
{
char dest[100*2];
memset(dest, 'C', 100*2-1); 
dest[100*2-1] = '\0'; 
strcpy(dest, data);
printLine(dest);
}
}
",1
5643,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(staticTrue)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
SNPRINTF(dest, wcslen(data), L""%s"", data);
printWLine(data);
}
}
",0
1534,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(staticReturnsTrue())
{
badVaSinkB(data, data);
}
}
",0
11320,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
goodB2GVaSink(data, data);
}
",1
18117,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
strcpy(data, ""fixedstringtest"");
}
if(globalReturnsTrue())
{
goodG2B2VaSinkB(data, data);
}
}
",1
16611,"void function()
{
short data;
data = 0;
if(globalTrue)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
17527,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
15254,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(STATIC_CONST_FIVE==5)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",1
11025,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(GLOBAL_CONST_TRUE)
{
goodB2G2VaSinkG(data, data);
}
}
",1
2550,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(globalReturnsTrue())
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
",0
3684,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
goto source;
source:
data = dataBadBuffer;
data[0] = L'\0'; 
{
wchar_t source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = wcslen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printWLine(data);
}
}
",0
7070,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(GLOBAL_CONST_FIVE==5)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = wcslen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printWLine(data);
}
}
",0
18340,"void function()
{
char * data;
data = NULL;
if(globalFive==5)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",1
12636,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memmove(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
12099,"void function()
{
short data;
data = 0;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
9663,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(staticFive==5)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcpy(dest, data);
printLine(data);
free(data);
}
}
",1
12987,"void function()
{
short data;
data = 0;
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
13832,"void function()
{
int * data;
data = NULL;
if(GLOBAL_CONST_FIVE==5)
{
data = (int *)ALLOCA(10*sizeof(int));
}
{
int source[10] = {0};
memcpy(data, source, 10*sizeof(int));
printIntLine(data[0]);
}
}
",1
19926,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
3162,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(globalTrue)
{
data = dataBadBuffer;
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",0
13197,"void function()
{
int h;
short data;
data = 0;
for(h = 0; h < 1; h++)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
11369,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive==5)
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
22775,"void function()
{
int data;
data = -1;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
20865,"void function()
{
char * data;
data = NULL;
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
break;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncat(data, source, 100);
printLine(data);
free(data);
}
}
",1
8442,"void function()
{
char * data;
CWE134_Uncontrolled_Format_String__char_environment_w32_vsnprintf_34_unionType myUnion;
char dataBuffer[100] = """";
data = dataBuffer;
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
goodB2GVaSink(data, data);
}
}
",1
13557,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
free(data);
}
}
",1
15453,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
wcscpy(data, L""fixedstringtest"");
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
goodG2BVaSink(data, data);
}
}
",1
15343,"void function()
{
char * data;
data = NULL;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
SNPRINTF(data, 100, ""%s"", source);
printLine(data);
free(data);
}
}
",1
13414,"void function()
{
if(1)
{
{
char src[150], dest[100];
int i;
memset(src, 'A', 149);
src[149] = '\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
dest[99] = '\0'; 
printLine(dest);
}
}
}
",1
4691,"void function()
{
wchar_t * data;
CWE127_Buffer_Underread__malloc_wchar_t_cpy_34_unionType myUnion;
data = NULL;
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t dest[100*2];
wmemset(dest, L'C', 100*2-1); 
dest[100*2-1] = L'\0'; 
wcscpy(dest, data);
printWLine(dest);
}
}
}
",0
14921,"void function()
{
short data;
data = 0;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
22810,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalReturnsTrue())
{
wcscpy(data, L""fixedstringtest"");
}
if(globalReturnsTrue())
{
goodG2B2VaSinkB(data, data);
}
}
",1
9529,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(5==5)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
14375,"void function()
{
int data;
data = -1;
if(globalTrue)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
free(buffer);
}
}
}
",1
4609,"void function()
{
int i;
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
for(i = 0; i < 1; i++)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
strcpy(dest, data);
printLine(data);
}
}
",0
3413,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalTrue)
{
data = dataBuffer - 8;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",0
17593,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
switch(6)
{
case 6:
strcpy(data, ""fixedstringtest"");
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
printf(data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
7492,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalReturnsTrue())
{
data = dataBuffer - 8;
}
{
char dest[100*2];
memset(dest, 'C', 100*2-1); 
dest[100*2-1] = '\0'; 
strcpy(dest, data);
printLine(dest);
}
}
",0
16219,"void function()
{
wchar_t * data;
data = NULL;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
6559,"void function()
{
int64_t * data;
int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
if(staticReturnsTrue())
{
data = dataBadBuffer;
}
{
int64_t source[100] = {0}; 
memmove(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",0
3587,"void function()
{
wchar_t * data;
data = NULL;
if(GLOBAL_CONST_TRUE)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
}
{
size_t i;
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
10034,"void function()
{
int * data;
data = NULL;
goto source;
source:
data = (int *)malloc(100*sizeof(int));
if (data == NULL) {exit(-1);}
{
int source[100] = {0}; 
memcpy(data, source, 100*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",1
21022,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
size_t i, dataLen;
dataLen = wcslen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
17831,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(1)
{
goodB2G2VaSinkG(data, data);
}
}
",1
13336,"void function()
{
int data;
data = -1;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
6412,"void function()
{
char * data;
data = NULL;
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",0
14718,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t dest[100*2];
wmemset(dest, L'C', 100*2-1); 
dest[100*2-1] = L'\0'; 
wcscpy(dest, data);
printWLine(dest);
}
}
",1
6239,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(globalFive==5)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",0
1701,"void function()
{
int i;
wchar_t * data;
data = NULL;
for(i = 0; i < 1; i++)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
}
{
wchar_t dest[100*2];
wmemset(dest, L'C', 100*2-1); 
dest[100*2-1] = L'\0'; 
wcscpy(dest, data);
printWLine(dest);
}
}
",0
4560,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
data = RAND32();
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
8251,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(STATIC_CONST_FIVE==5)
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
4622,"void function()
{
wchar_t * data;
data = NULL;
if(5==5)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memcpy(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
10533,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalTrue)
{
wprintf(L""%s\n"", data);
}
}
",1
7295,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticTrue)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",0
22705,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
strcpy(data, ""fixedstringtest"");
{
char * dataCopy = data;
char * data = dataCopy;
printf(data);
}
}
",1
2953,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(globalTrue)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",0
6670,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(globalFive==5)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",0
3563,"void function()
{
short data;
data = 0;
if(staticFive==5)
{
data = -1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
9547,"void function()
{
char * data;
data = NULL;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
21433,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
while(1)
{
data = dataGoodBuffer;
data[0] = '\0'; 
break;
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",1
13098,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
strcpy(data, ""fixedstringtest"");
break;
}
switch(7)
{
case 7:
fprintf(stdout, data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
3941,"void function()
{
char * data;
data = NULL;
if(1)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memmove(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
15054,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(staticFive==5)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
memmove(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
4028,"void function()
{
char * data;
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_34_unionType myUnion;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
data = dataBadBuffer;
data[0] = '\0'; 
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
}
}
}
",0
13741,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(staticFive==5)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
free(data);
}
}
",1
15503,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
6523,"void function()
{
int data;
data = -1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
free(buffer);
}
}
",0
12658,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FIVE==5)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
15050,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
while(1)
{
data = dataGoodBuffer;
data[0] = '\0'; 
break;
}
{
char source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = strlen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printLine(data);
}
}
",1
12002,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",1
14078,"void function()
{
wchar_t * data;
CWE122_Heap_Based_Buffer_Overflow__c_CWE806_wchar_t_memmove_34_unionType myUnion;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t dest[50] = L"""";
memmove(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
}
",1
2787,"void function()
{
if(staticFive==5)
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid->voidSecond);
memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid->charFirst);
printWLine((wchar_t *)structCharVoid->voidSecond);
}
}
}
",0
17627,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(STATIC_CONST_TRUE)
{
data = dataBuffer;
}
{
size_t i;
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",1
1977,"void function()
{
if(5==5)
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid->voidSecond);
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid->charFirst);
printLine((char *)structCharVoid->voidSecond);
free(structCharVoid);
}
}
}
",0
9353,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
goto source;
source:
data = dataBuffer;
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",1
8024,"void function()
{
int data;
data = -1;
goto source;
source:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
6982,"void function()
{
wchar_t * data;
data = NULL;
if(STATIC_CONST_FIVE==5)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
}
{
wchar_t dest[100*2];
wmemset(dest, L'C', 100*2-1); 
dest[100*2-1] = L'\0'; 
wcscpy(dest, data);
printWLine(dest);
}
}
",0
14888,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(1)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
19651,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
11562,"void function()
{
int data;
data = -1;
if(globalFive==5)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
572,"void function()
{
switch(6)
{
case 6:
{
char src[150], dest[100];
int i;
memset(src, 'A', 149);
src[149] = '\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
printLine(dest);
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",0
19428,"void function()
{
int data;
data = -1;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
3158,"void function()
{
char * data;
data = NULL;
if(globalFive==5)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",0
14085,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncpy(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
8724,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
19884,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
22748,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(1)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(1)
{
wprintf(L""%s\n"", data);
}
}
",1
17638,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100];
data = dataBuffer;
{
char * data = *dataPtr1;
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
}
",1
1850,"void function()
{
int64_t * data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
if(staticTrue)
{
data = dataBadBuffer;
}
{
int64_t source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printLongLongLine(data[0]);
}
}
}
",0
12605,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(staticTrue)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
15504,"void function()
{
int h,j;
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
for(h = 0; h < 1; h++)
{
strcpy(data, ""fixedstringtest"");
}
for(j = 0; j < 1; j++)
{
fprintf(stdout, data);
}
}
",1
5891,"void function()
{
char * data;
data = NULL;
if(GLOBAL_CONST_FIVE==5)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
}
{
char dest[100*2];
memset(dest, 'C', 100*2-1); 
dest[100*2-1] = '\0'; 
strcpy(dest, data);
printLine(dest);
}
}
",0
13804,"void function()
{
int * data;
data = NULL;
if(GLOBAL_CONST_FIVE==5)
{
data = (int *)malloc(10*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[10] = {0};
memmove(data, source, 10*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",1
955,"void function()
{
char * data;
data = NULL;
if(globalTrue)
{
data = (char *)malloc(10*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
}
}
",0
23179,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(staticTrue)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
13933,"void function()
{
int h;
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
for(h = 0; h < 1; h++)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
size_t i, dataLen;
dataLen = wcslen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
17621,"void function()
{
char * data;
data = NULL;
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
break;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
",1
10334,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FIVE==5)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
17903,"void function()
{
short data;
data = 0;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
6408,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalFive==5)
{
badVaSinkB(data, data);
}
}
",0
2712,"void function()
{
int i,j;
int data;
data = -1;
for(i = 0; i < 1; i++)
{
fscanf(stdin, ""%d"", &data);
}
for(j = 0; j < 1; j++)
{
{
int buffer[10] = { 0 };
if (data >= 0)
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is negative"");
}
}
}
}
",0
16762,"void function()
{
{
charVoid structCharVoid;
structCharVoid.voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid.voidSecond);
memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid.charFirst);
printWLine((wchar_t *)structCharVoid.voidSecond);
}
}
",1
16178,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalFive==5)
{
data = dataBuffer;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
",1
13828,"void function()
{
char * data;
data = NULL;
if(globalFive==5)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memmove(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
13565,"void function()
{
int * data;
int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
int source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
}
}
}
",1
3297,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(staticFive==5)
{
data = dataBadBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memcpy(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
20961,"void function()
{
int h;
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
for(h = 0; h < 1; h++)
{
data = dataBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memmove(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
18799,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(GLOBAL_CONST_TRUE)
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
12121,"void function()
{
wchar_t * data;
data = NULL;
switch(6)
{
case 6:
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscat(data, source);
printWLine(data);
free(data);
}
}
",1
13794,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
11495,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(globalFive==5)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = strlen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printLine(data);
}
}
",1
304,"void function()
{
short data;
data = 0;
if(GLOBAL_CONST_TRUE)
{
fscanf (stdin, ""%hd"", &data);
}
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
",0
7184,"void function()
{
short data;
data = 0;
goto source;
source:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
11880,"void function()
{
int h;
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
for(h = 0; h < 1; h++)
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
strncpy(dest, data, strlen(dest));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
14061,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFive==5)
{
wcscpy(data, L""fixedstringtest"");
}
if(globalFive==5)
{
goodG2B2VaSinkB(data, data);
}
}
",1
19435,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(5==5)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
19005,"void function()
{
wchar_t * data;
CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_w32_vsnprintf_34_unionType myUnion;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
wcscpy(data, L""fixedstringtest"");
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
goodG2BVaSink(data, data);
}
}
",1
15242,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
data = NULL;
{
char * data = *dataPtr1;
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
}
}
}
",1
20444,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5==5)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
5950,"void function()
{
int i;
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
for(i = 0; i < 1; i++)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strncpy(data, source, strlen(source) + 1);
printLine(data);
}
}
",0
637,"void function()
{
short data;
data = 0;
switch(6)
{
case 6:
data = (short)RAND32();
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
2466,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
{
wchar_t * data = *dataPtr1;
data = dataBuffer - 8;
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memmove(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
}
",0
1585,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(1)
{
data = dataBadBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memmove(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
18314,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsTrue())
{
printf(""%s\n"", data);
}
}
",1
8075,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(GLOBAL_CONST_TRUE)
{
data = dataBuffer - 8;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
",0
4761,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBadBuffer;
data[0] = '\0'; 
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0'; 
printLine(data);
}
}
",0
6980,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(globalTrue)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncat(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",0
21100,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memmove(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
10633,"void function()
{
wchar_t * data;
CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_fprintf_34_unionType myUnion;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
wcscpy(data, L""fixedstringtest"");
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
fwprintf(stdout, data);
}
}
",1
869,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
char * dataCopy = data;
char * data = dataCopy;
badVaSink(data, data);
}
}
",0
16697,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(globalFive==5)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
15366,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
9432,"void function()
{
char * data;
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_declare_ncat_34_unionType myUnion;
char dataBuffer[100];
data = dataBuffer;
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
}
",1
19693,"void function()
{
if(5==5)
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid->voidSecond);
memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid->charFirst);
printWLine((wchar_t *)structCharVoid->voidSecond);
}
}
}
",1
4256,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(globalReturnsTrue())
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",0
17525,"void function()
{
int * data;
data = NULL;
if(staticTrue)
{
data = (int *)malloc(10*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[10] = {0};
memmove(data, source, 10*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",1
10690,"void function()
{
int * data;
data = NULL;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (int *)malloc(100*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
free(data);
}
}
}
",1
9772,"void function()
{
short data;
data = 0;
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
17753,"void function()
{
int data;
data = -1;
if(staticTrue)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
10467,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
data = RAND32();
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
free(buffer);
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
13115,"void function()
{
char * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
}
}
",1
12790,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalFive==5)
{
strcpy(data, ""fixedstringtest"");
}
if(globalFive==5)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",1
17481,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
data = dataGoodBuffer;
data[0] = L'\0'; 
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscat(data, source);
printWLine(data);
}
}
}
",1
6302,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsTrue())
{
wprintf(data);
}
}
",0
11382,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
1565,"void function()
{
int data;
data = -1;
if(staticTrue)
{
data = RAND32();
}
if(staticTrue)
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
free(buffer);
}
}
}
",0
2790,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(globalFive==5)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",0
4642,"void function()
{
int i;
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
for(i = 0; i < 1; i++)
{
data = dataBuffer - 8;
}
{
size_t i;
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",0
7466,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
memcpy(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
16779,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
8668,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(5==5)
{
goodG2B1VaSinkB(data, data);
}
}
",1
22698,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(STATIC_CONST_FIVE==5)
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
1711,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
goto source;
source:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
goto sink;
sink:
badVaSinkB(data, data);
}
",0
12738,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
SNPRINTF(data, 100, L""%s"", source);
printWLine(data);
}
}
",1
1209,"void function()
{
int data;
data = -1;
if(globalFive==5)
{
fscanf(stdin, ""%d"", &data);
}
if(globalFive==5)
{
{
int buffer[10] = { 0 };
if (data >= 0)
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is negative"");
}
}
}
}
",0
10081,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
break;
}
{
wchar_t dest[50] = L"""";
size_t i, dataLen;
dataLen = wcslen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
1849,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBadBuffer;
data[0] = '\0'; 
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",0
942,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive==5)
{
badVaSinkB(data, data);
}
}
",0
22944,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",1
22724,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalFive==5)
{
data = dataBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memmove(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
2756,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalFive==5)
{
data = dataBuffer - 8;
}
{
size_t i;
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
6161,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
memcpy(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
11636,"void function()
{
int * data;
data = NULL;
data = (int *)malloc(100*sizeof(int));
if (data == NULL) {exit(-1);}
{
int source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
free(data);
}
}
}
",1
15260,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
3947,"void function()
{
int i;
int data;
data = -1;
for(i = 0; i < 1; i++)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
13558,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
15258,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
14164,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0';
printWLine(data);
}
}
",1
5328,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalReturnsTrue())
{
data = dataBuffer - 8;
}
{
size_t i;
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",0
16550,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive==5)
{
strcpy(data, ""fixedstringtest"");
}
if(staticFive==5)
{
goodG2B2VaSinkB(data, data);
}
}
",1
10592,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
goto source;
source:
strcpy(data, ""fixedstringtest"");
goto sink;
sink:
goodG2BVaSinkB(data, data);
}
",1
18089,"void function()
{
wchar_t * data;
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncpy_34_unionType myUnion;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t dest[50] = L"""";
wcsncpy(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
}
",1
17879,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsTrue())
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
7481,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
goto source;
source:
data = dataBuffer - 8;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
23222,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
3585,"void function()
{
int * data;
int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
if(STATIC_CONST_TRUE)
{
data = dataBadBuffer;
}
{
int source[100] = {0}; 
memmove(data, source, 100*sizeof(int));
printIntLine(data[0]);
}
}
",0
18735,"void function()
{
void * data;
data = NULL;
if(1)
{
data = (void *)WIDE_STRING;
}
if(1)
{
{
size_t dataLen = wcslen((wchar_t *)data);
void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
(void)wcscpy(dest, data);
printWLine((wchar_t *)dest);
}
}
}
",1
9709,"void function()
{
int h;
char * data;
data = NULL;
for(h = 0; h < 1; h++)
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
21839,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_TRUE)
{
goodB2G2VaSinkG(data, data);
}
}
",1
14594,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(globalTrue)
{
goodG2B1VaSinkB(data, data);
}
}
",1
23156,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
goodB2G2VaSinkG(data, data);
}
}
",1
15601,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0';
printWLine(data);
}
}
",1
17458,"void function()
{
wchar_t * data;
data = NULL;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
3021,"void function()
{
int data;
data = -1;
if(1)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(1)
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
free(buffer);
}
}
}
",0
8728,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
wcscpy(data, L""fixedstringtest"");
}
if(STATIC_CONST_FIVE==5)
{
wprintf(data);
}
}
",1
15526,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalTrue)
{
strcpy(data, ""fixedstringtest"");
}
if(globalTrue)
{
printf(data);
}
}
",1
16162,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_TRUE)
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
12952,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
19089,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
wcscpy(data, L""fixedstringtest"");
}
if(staticReturnsTrue())
{
wprintf(data);
}
}
",1
654,"void function()
{
wchar_t * data;
CWE121_Stack_Based_Buffer_Overflow__CWE193_wchar_t_declare_ncpy_34_unionType myUnion;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
data = dataBadBuffer;
data[0] = L'\0'; 
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
}
}
}
",0
1864,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(5==5)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",0
3830,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(GLOBAL_CONST_TRUE)
{
badVaSinkB(data, data);
}
}
",0
14556,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(5==5)
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
15369,"void function()
{
wchar_t * data;
data = NULL;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
5961,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(STATIC_CONST_FIVE==5)
{
badVaSinkB(data, data);
}
}
",0
8002,"void function()
{
int data;
data = -1;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
",0
9822,"void function()
{
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid->voidSecond);
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid->charFirst);
printWLine((wchar_t *)structCharVoid->voidSecond);
free(structCharVoid);
}
}
}
",1
7834,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
while(1)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
break;
}
while(1)
{
fprintf(stdout, data);
break;
}
}
",0
15203,"void function()
{
wchar_t * data;
data = NULL;
if(5==5)
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
18755,"void function()
{
short data;
data = 0;
if(GLOBAL_CONST_FIVE==5)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
12751,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(staticReturnsTrue())
{
fprintf(stdout, data);
}
}
",1
1684,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(GLOBAL_CONST_TRUE)
{
badVaSinkB(data, data);
}
}
",0
16687,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncat(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
5942,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
fwprintf(stdout, data);
}
}
",0
17174,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcat(data, source);
printLine(data);
}
}
",1
21647,"void function()
{
char * data;
data = NULL;
if(GLOBAL_CONST_TRUE)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
strncpy(dest, data, strlen(dest));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
3550,"void function()
{
wchar_t * data;
data = NULL;
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memmove(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
}
",0
7517,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(STATIC_CONST_TRUE)
{
badVaSinkB(data, data);
}
}
",0
9248,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
switch(6)
{
case 6:
data = dataGoodBuffer;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memcpy(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
3912,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(GLOBAL_CONST_TRUE)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strncpy(data, source, strlen(source) + 1);
printLine(data);
}
}
",0
22931,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalReturnsTrue())
{
wcscpy(data, L""fixedstringtest"");
}
if(globalReturnsTrue())
{
goodG2B2VaSinkB(data, data);
}
}
",1
9765,"void function()
{
char * data;
data = NULL;
if(5==5)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
14637,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
10488,"void function()
{
int data;
data = -1;
if(staticTrue)
{
data = RAND32();
}
if(staticTrue)
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
2979,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
while(1)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
break;
}
{
wchar_t dest[50] = L"""";
wcsncat(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",0
2489,"void function()
{
int i;
twoIntsStruct * data;
twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
for(i = 0; i < 1; i++)
{
data = dataBadBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memcpy(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",0
17376,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",1
4220,"void function()
{
wchar_t * data;
data = NULL;
if(staticFive==5)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memmove(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
9910,"void function()
{
wchar_t * data;
data = NULL;
if(globalTrue)
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
SNPRINTF(data, 100, L""%s"", source);
printWLine(data);
free(data);
}
}
",1
16167,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
4886,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(1)
{
data = dataBuffer - 8;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",0
5202,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",0
3331,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(1)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",0
8202,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
{
char * dataCopy = data;
char * data = dataCopy;
badVaSink(data, data);
}
}
",0
1629,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
switch(6)
{
case 6:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
fwprintf(stdout, data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",0
10920,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
strcpy(data, ""fixedstringtest"");
}
if(GLOBAL_CONST_FIVE==5)
{
goodG2B2VaSinkB(data, data);
}
}
",1
14902,"void function()
{
int data;
data = -1;
if(globalFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalFive==5)
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
10147,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(staticFive==5)
{
printf(""%s\n"", data);
}
}
",1
2860,"void function()
{
short data;
data = 0;
if(GLOBAL_CONST_TRUE)
{
data = (short)RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
8227,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
switch(6)
{
case 6:
data = dataBadBuffer;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",0
2752,"void function()
{
short data;
data = 0;
if(STATIC_CONST_TRUE)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = (short)atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
5339,"void function()
{
short data;
data = 0;
if(GLOBAL_CONST_TRUE)
{
data = (short)RAND32();
}
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
",0
13775,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive==5)
{
strcpy(data, ""fixedstringtest"");
}
if(staticFive==5)
{
goodG2B2VaSinkB(data, data);
}
}
",1
655,"void function()
{
int * data;
data = NULL;
if(globalReturnsTrue())
{
data = (int *)malloc(10);
if (data == NULL) {exit(-1);}
}
{
int source[10] = {0};
memmove(data, source, 10*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",0
96,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(globalTrue)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscat(data, source);
printWLine(data);
}
}
",0
21881,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(1)
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
15578,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
strcpy(data, ""fixedstringtest"");
}
if(1)
{
goodG2B2VaSinkB(data, data);
}
}
",1
12401,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(GLOBAL_CONST_TRUE)
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
12637,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",1
9900,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
21826,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(GLOBAL_CONST_TRUE)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
}
}
",1
20857,"void function()
{
char * data;
data = NULL;
if(staticReturnsTrue())
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
",1
747,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFive==5)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(globalFive==5)
{
wprintf(data);
}
}
",0
20936,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
switch(6)
{
case 6:
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
fprintf(stdout, ""%s\n"", data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
8058,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(STATIC_CONST_TRUE)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
memmove(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",0
16282,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticFive==5)
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
4604,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(globalReturnsTrue())
{
data = dataBadBuffer;
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",0
9495,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
12416,"void function()
{
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
{
char data[150], dest[100];
memset(data, 'A', 149);
data[149] = '\0';
strncpy(dest, data, 99);
dest[99] = '\0'; 
printLine(dest);
}
}
}
",1
22791,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memmove(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
4273,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
data = dataBadBuffer;
data[0] = L'\0'; 
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
}
}
}
",0
4921,"void function()
{
int data;
data = -1;
if(1)
{
data = RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
5111,"void function()
{
short data;
data = 0;
if(staticFive==5)
{
fscanf (stdin, ""%hd"", &data);
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
13041,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticTrue)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(staticTrue)
{
printf(""%s\n"", data);
}
}
",1
22022,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
goto source;
source:
data = dataBuffer;
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memmove(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
5708,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(5==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(5==5)
{
badVaSinkB(data, data);
}
}
",0
3548,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalTrue)
{
data = dataBuffer - 8;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0';
printWLine(data);
}
}
",0
3230,"void function()
{
int * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
data = (int *)ALLOCA(10);
}
{
int source[10] = {0};
memmove(data, source, 10*sizeof(int));
printIntLine(data[0]);
}
}
",0
1693,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
goto source;
source:
data = dataBuffer - 8;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memmove(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
12652,"void function()
{
int data;
data = -1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
",1
16364,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
while(1)
{
data = dataGoodBuffer;
data[0] = '\0'; 
break;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncat(data, source, 100);
printLine(data);
}
}
",1
17514,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
data = dataGoodBuffer;
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
}
",1
16288,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
while(1)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
break;
}
while(1)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
break;
}
}
",1
20995,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(globalReturnsTrue())
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
memcpy(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
16657,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memmove(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
12317,"void function()
{
int data;
data = -1;
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
5946,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
",0
14018,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
size_t i, dataLen;
dataLen = wcslen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
12998,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5==5)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
4547,"void function()
{
int data;
data = -1;
if(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(1)
{
{
int buffer[10] = { 0 };
if (data < 10)
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is too big."");
}
}
}
}
",0
9787,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(1)
{
wcscpy(data, L""fixedstringtest"");
}
if(1)
{
goodG2B2VaSinkB(data, data);
}
}
",1
1364,"void function()
{
char * data;
data = NULL;
if(1)
{
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",0
7548,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(STATIC_CONST_FIVE==5)
{
data = dataBuffer - 8;
}
{
size_t i;
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",0
17228,"void function()
{
if(1)
{
{
wchar_t src[150], dest[100];
int i;
wmemset(src, L'A', 149);
src[149] = L'\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
dest[99] = L'\0'; 
printWLine(dest);
}
}
}
",1
7023,"void function()
{
if(globalTrue)
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid->voidSecond);
memmove(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid->charFirst);
printWLine((wchar_t *)structCharVoid->voidSecond);
}
}
}
",0
17979,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
SNPRINTF(data, 100, L""%s"", source);
printWLine(data);
}
}
",1
10726,"void function()
{
void * data;
data = NULL;
switch(6)
{
case 6:
{
wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
if (dataBadBuffer == NULL) {exit(-1);}
wmemset(dataBadBuffer, L'A', 50-1);
dataBadBuffer[50-1] = L'\0';
data = (void *)dataBadBuffer;
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
{
size_t dataLen = wcslen((wchar_t *)data);
void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
if (dest == NULL) {exit(-1);}
(void)wcscpy(dest, data);
printWLine((wchar_t *)dest);
free(dest);
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
12175,"void function()
{
char * data;
data = NULL;
if(staticReturnsTrue())
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",1
3949,"void function()
{
short data;
data = 0;
goto source;
source:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
3316,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(5==5)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
18915,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5==5)
{
wcscpy(data, L""fixedstringtest"");
}
if(5==5)
{
goodG2B2VaSinkB(data, data);
}
}
",1
5841,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
{
wchar_t * data = *dataPtr1;
data = dataBadBuffer;
data[0] = L'\0'; 
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
}
",0
12914,"void function()
{
wchar_t * data;
data = NULL;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
",1
16978,"void function()
{
int64_t * data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
int64_t source[100] = {0}; 
memcpy(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",1
13372,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100] = """";
data = dataBuffer;
{
char * data = *dataPtr1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
goodB2GVaSink(data, data);
}
}
",1
17156,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
free(data);
}
}
",1
21739,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncpy(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
2436,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
badVaSink(data, data);
}
}
",0
23147,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(GLOBAL_CONST_TRUE)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
16029,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
14871,"void function()
{
int data;
data = -1;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
21838,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
{
wchar_t * data = *dataPtr1;
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t dest[50] = L"""";
size_t i, dataLen;
dataLen = wcslen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = L'\0'; 
printWLine(data);
}
}
}
",1
239,"void function()
{
int64_t * data;
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_int64_t_memmove_34_unionType myUnion;
data = NULL;
data = (int64_t *)malloc(50*sizeof(int64_t));
if (data == NULL) {exit(-1);}
myUnion.unionFirst = data;
{
int64_t * data = myUnion.unionSecond;
{
int64_t source[100] = {0}; 
memmove(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
free(data);
}
}
}
",0
17988,"void function()
{
int data;
data = -1;
goto source;
source:
data = 100-1;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
22981,"void function()
{
int data;
data = -1;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
20537,"void function()
{
int h;
wchar_t * data;
data = NULL;
for(h = 0; h < 1; h++)
{
data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
}
{
wchar_t source[10+1] = SRC_STRING;
memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
free(data);
}
}
",1
19733,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalFive==5)
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
11414,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncat(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
21668,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
6056,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(1)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
SNPRINTF(dest, strlen(data), ""%s"", data);
printLine(data);
free(data);
}
}
",0
15341,"void function()
{
wchar_t * data;
data = NULL;
while(1)
{
data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
break;
}
{
wchar_t source[10+1] = SRC_STRING;
memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
free(data);
}
}
",1
1590,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
badVaSinkB(data, data);
}
}
",0
13498,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100] = """";
data = dataBuffer;
{
char * data = *dataPtr1;
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
printf(""%s\n"", data);
}
}
",1
18951,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
goto source;
source:
data = dataBuffer;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
",1
730,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(GLOBAL_CONST_FIVE==5)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",0
18026,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(globalReturnsTrue())
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
17682,"void function()
{
void * data;
data = NULL;
data = (void *)CHAR_STRING;
{
void * dataCopy = data;
void * data = dataCopy;
{
size_t dataLen = strlen((char *)data);
void * dest = (void *)ALLOCA((dataLen+1) * 1);
(void)strcpy(dest, data);
printLine((char *)dest);
}
}
}
",1
7431,"void function()
{
int * data;
CWE121_Stack_Based_Buffer_Overflow__CWE131_loop_34_unionType myUnion;
data = NULL;
data = (int *)ALLOCA(10);
myUnion.unionFirst = data;
{
int * data = myUnion.unionSecond;
{
int source[10] = {0};
size_t i;
for (i = 0; i < 10; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
}
}
}
",0
11714,"void function()
{
char * data;
data = NULL;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",1
2767,"void function()
{
twoIntsStruct * data;
twoIntsStruct dataBadBuffer[50];
twoIntsStruct dataGoodBuffer[100];
data = dataBadBuffer;
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memcpy(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",0
23022,"void function()
{
int data;
data = -1;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
165,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
wchar_t * data = *dataPtr1;
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
badVaSink(data, data);
}
}
",0
17052,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(GLOBAL_CONST_TRUE)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
}
}
",1
8631,"void function()
{
if(staticTrue)
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid->voidSecond);
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid->charFirst);
printLine((char *)structCharVoid->voidSecond);
free(structCharVoid);
}
}
}
",1
15670,"void function()
{
char * data;
data = NULL;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
3741,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(staticReturnsTrue())
{
data = dataBadBuffer;
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",0
16517,"void function()
{
int data;
data = -1;
while(1)
{
data = RAND32();
break;
}
while(1)
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
break;
}
}
",1
15215,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(STATIC_CONST_FIVE==5)
{
goodB2G2VaSinkG(data, data);
}
}
",1
7093,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(STATIC_CONST_FIVE==5)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",0
18682,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
wcscpy(data, L""fixedstringtest"");
}
if(staticFive==5)
{
goodG2B2VaSinkB(data, data);
}
}
",1
20754,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
}
}
",1
3089,"void function()
{
int data;
CWE124_Buffer_Underwrite__CWE839_listen_socket_34_unionType myUnion;
data = -1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
myUnion.unionFirst = data;
{
int data = myUnion.unionSecond;
{
int i;
int buffer[10] = { 0 };
if (data < 10)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
}
}
}
",0
20161,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
switch(6)
{
case 6:
data = dataGoodBuffer;
data[0] = L'\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
SNPRINTF(data, 100, L""%s"", source);
printWLine(data);
}
}
",1
11551,"void function()
{
wchar_t * data;
data = NULL;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
6664,"void function()
{
short data;
CWE194_Unexpected_Sign_Extension__fscanf_strncpy_34_unionType myUnion;
data = 0;
fscanf (stdin, ""%hd"", &data);
myUnion.unionFirst = data;
{
short data = myUnion.unionSecond;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",0
21980,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
19480,"void function()
{
int data;
data = -1;
if(1)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(1)
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
2146,"void function()
{
int i;
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
for(i = 0; i < 1; i++)
{
data = dataBuffer - 8;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
15226,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
SNPRINTF(dest, strlen(data), ""%s"", data);
printLine(data);
}
}
",1
20768,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
277,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
data = dataBadBuffer;
data[0] = L'\0'; 
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
}
}
",0
2348,"void function()
{
char * data;
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_memcpy_34_unionType myUnion;
data = NULL;
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
}
",0
8347,"void function()
{
wchar_t * data;
data = NULL;
if(staticTrue)
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
",1
7397,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(staticFive==5)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",0
7751,"void function()
{
int data;
data = -1;
if(1)
{
fscanf(stdin, ""%d"", &data);
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
10973,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
break;
}
{
wchar_t dest[50] = L"""";
memmove(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
8096,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(staticFive==5)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = wcslen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printWLine(data);
}
}
",0
13679,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
while(1)
{
strcpy(data, ""fixedstringtest"");
break;
}
while(1)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
break;
}
}
",1
7040,"void function()
{
wchar_t * data;
data = NULL;
if(GLOBAL_CONST_TRUE)
{
data = (wchar_t *)malloc(10*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
}
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
free(data);
}
}
",0
11855,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
while(1)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
break;
}
{
char dest[50] = """";
size_t i, dataLen;
dataLen = strlen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
12128,"void function()
{
int h;
char * data;
data = NULL;
for(h = 0; h < 1; h++)
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memmove(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
free(data);
}
}
",1
22893,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsTrue())
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(staticReturnsTrue())
{
goodB2G2VaSinkG(data, data);
}
}
",1
12711,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FIVE==5)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
20609,"void function()
{
char * data;
data = NULL;
if(staticTrue)
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
22290,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE==5)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
18045,"void function()
{
int h;
int data;
data = -1;
for(h = 0; h < 1; h++)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
9404,"void function()
{
int h;
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
for(h = 0; h < 1; h++)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",1
18677,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
memcpy(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
10489,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(5==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
5730,"void function()
{
short data;
data = 0;
if(staticReturnsTrue())
{
data = -1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
960,"void function()
{
goto sink;
sink:
{
wchar_t data[150], dest[100];
wmemset(data, L'A', 149);
data[149] = L'\0';
memcpy(dest, data, 99*sizeof(wchar_t));
printWLine(dest);
}
}
",0
20411,"void function()
{
wchar_t * data;
data = NULL;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memcpy(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
5360,"void function()
{
wchar_t * data;
data = NULL;
switch(6)
{
case 6:
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
",0
5168,"void function()
{
wchar_t * data;
data = NULL;
switch(6)
{
case 6:
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",0
10759,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
{
char * dataCopy = data;
char * data = dataCopy;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
}
",1
20324,"void function()
{
int h;
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
for(h = 0; h < 1; h++)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",1
7531,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
fwprintf(stdout, data);
}
",0
10515,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100] = """";
data = dataBuffer;
{
char * data = *dataPtr1;
strcpy(data, ""fixedstringtest"");
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",1
11239,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
7800,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
19655,"void function()
{
char * data;
data = NULL;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",1
2710,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(globalReturnsTrue())
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
}
}
",0
15397,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
goodB2GVaSink(data, data);
}
}
",1
15488,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",1
4650,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(STATIC_CONST_TRUE)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
SNPRINTF(dest, strlen(data), ""%s"", data);
printLine(data);
free(data);
}
}
",0
22678,"void function()
{
int data;
data = -1;
if(5==5)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
17118,"void function()
{
int data;
data = -1;
if(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(1)
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
free(buffer);
}
}
}
",1
2524,"void function()
{
int data;
int *dataPtr1 = &data;
int *dataPtr2 = &data;
data = -1;
{
int data = *dataPtr1;
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
*dataPtr1 = data;
}
{
int data = *dataPtr2;
{
int i;
int buffer[10] = { 0 };
if (data >= 0)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
}
}
}
",0
11743,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
{
wchar_t * data = *dataPtr1;
data = dataGoodBuffer;
data[0] = L'\0'; 
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
}
",1
404,"void function()
{
wchar_t * data;
data = NULL;
if(globalTrue)
{
data = (wchar_t *)malloc(10*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
free(data);
}
}
",0
9475,"void function()
{
short data;
data = 0;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
2622,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
goto source;
source:
data = dataBadBuffer;
data[0] = '\0'; 
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",0
3628,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(GLOBAL_CONST_TRUE)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscat(data, source);
printWLine(data);
}
}
",0
5976,"void function()
{
int data;
data = -1;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
11082,"void function()
{
wchar_t * data;
data = NULL;
if(5==5)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
size_t i;
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
14104,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(1)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncat(data, source, 100);
printLine(data);
}
}
",1
17448,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
data = dataGoodBuffer;
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
}
",1
16473,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
12994,"void function()
{
int64_t * data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
if(staticTrue)
{
data = dataGoodBuffer;
}
{
int64_t source[100] = {0}; 
memmove(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",1
621,"void function()
{
int64_t * data;
data = NULL;
if(globalTrue)
{
data = (int64_t *)malloc(50*sizeof(int64_t));
if (data == NULL) {exit(-1);}
}
{
int64_t source[100] = {0}; 
memcpy(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
free(data);
}
}
",0
14103,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
strncpy(dest, data, strlen(dest));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
1152,"void function()
{
wchar_t * data;
data = NULL;
if(STATIC_CONST_FIVE==5)
{
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memmove(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
",0
17241,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalReturnsTrue())
{
data = dataBuffer;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",1
19294,"void function()
{
int data;
data = -1;
if(globalFive==5)
{
fscanf(stdin, ""%d"", &data);
}
if(globalFive==5)
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
768,"void function()
{
short data;
data = 0;
if(STATIC_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
20352,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
{
wchar_t * data = *dataPtr1;
data = dataGoodBuffer;
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memmove(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
}
",1
21271,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(staticFive==5)
{
data = dataBuffer;
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
",1
14171,"void function()
{
if(globalReturnsTrue())
{
{
charVoid structCharVoid;
structCharVoid.voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid.voidSecond);
memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid.charFirst);
printLine((char *)structCharVoid.voidSecond);
}
}
}
",1
19091,"void function()
{
int data;
int *dataPtr1 = &data;
int *dataPtr2 = &data;
data = -1;
{
int data = *dataPtr1;
data = RAND32();
*dataPtr1 = data;
}
{
int data = *dataPtr2;
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
23063,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
data = dataBuffer;
break;
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
",1
15966,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5==5)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wprintf(L""%s\n"", data);
}
}
",1
13988,"void function()
{
char * data;
data = NULL;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
12492,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(staticReturnsTrue())
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
size_t i, dataLen;
dataLen = strlen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
7411,"void function()
{
char * data;
data = NULL;
data = (char *)malloc(10*sizeof(char));
if (data == NULL) {exit(-1);}
{
char * dataCopy = data;
char * data = dataCopy;
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
free(data);
}
}
}
",0
18826,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
7792,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
data = dataBadBuffer;
data[0] = L'\0'; 
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",0
21043,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",1
7775,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(STATIC_CONST_TRUE)
{
data = dataBadBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memcpy(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
13118,"void function()
{
int * data;
data = NULL;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = (int *)malloc(100*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[100] = {0}; 
memcpy(data, source, 100*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",1
4412,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(staticTrue)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
2174,"void function()
{
int data;
data = -1;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalTrue)
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
free(buffer);
}
}
}
",0
6262,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",0
10806,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(5==5)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
2071,"void function()
{
int64_t * data;
data = NULL;
if(GLOBAL_CONST_FIVE==5)
{
data = (int64_t *)malloc(50*sizeof(int64_t));
if (data == NULL) {exit(-1);}
}
{
int64_t source[100] = {0}; 
memcpy(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
free(data);
}
}
",0
4857,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
while(1)
{
data = dataBuffer - 8;
break;
}
{
char dest[100*2];
memset(dest, 'C', 100*2-1); 
dest[100*2-1] = '\0'; 
strcpy(dest, data);
printLine(dest);
}
}
",0
7574,"void function()
{
wchar_t * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
SNPRINTF(data, 100, L""%s"", source);
printWLine(data);
free(data);
}
}
",0
12438,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5==5)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
4507,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(STATIC_CONST_FIVE==5)
{
data = dataBadBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memcpy(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
13695,"void function()
{
int data;
data = -1;
if(STATIC_CONST_TRUE)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
17810,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
switch(6)
{
case 6:
strcpy(data, ""fixedstringtest"");
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
goodG2B2VaSinkB(data, data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
8944,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
8725,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticTrue)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticTrue)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
12032,"void function()
{
twoIntsStruct * data;
twoIntsStruct dataBadBuffer[50];
twoIntsStruct dataGoodBuffer[100];
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",1
9611,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
goto source;
source:
wcscpy(data, L""fixedstringtest"");
goto sink;
sink:
goodG2BVaSinkB(data, data);
}
",1
22939,"void function()
{
int data;
data = -1;
if(globalFive==5)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
6555,"void function()
{
int data;
data = -1;
if(staticTrue)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
3543,"void function()
{
char * data;
data = NULL;
if(STATIC_CONST_FIVE==5)
{
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",0
20816,"void function()
{
int h;
char * data;
data = NULL;
for(h = 0; h < 1; h++)
{
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = strlen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printLine(data);
free(data);
}
}
",1
3066,"void function()
{
int data;
data = -1;
goto source;
source:
fscanf(stdin, ""%d"", &data);
goto sink;
sink:
{
int buffer[10] = { 0 };
if (data >= 0)
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is negative"");
}
}
}
",0
12968,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
goto source;
source:
wcscpy(data, L""fixedstringtest"");
goto sink;
sink:
goodG2BVaSinkB(data, data);
}
",1
8866,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalFive==5)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
13168,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(globalTrue)
{
goodB2G2VaSinkG(data, data);
}
}
",1
9071,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_TRUE)
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
1068,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(staticFive==5)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcat(data, source);
printLine(data);
}
}
",0
19463,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(STATIC_CONST_TRUE)
{
data = dataBuffer;
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
",1
11999,"void function()
{
wchar_t * data;
data = NULL;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memmove(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
",1
9409,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(staticTrue)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
",1
13693,"void function()
{
int data;
data = -1;
if(1)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
2470,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
while(1)
{
data = dataBadBuffer;
data[0] = '\0'; 
break;
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",0
4501,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t dest[50] = L"""";
wcscat(dest, data);
printWLine(data);
free(data);
}
}
}
",0
127,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
switch(6)
{
case 6:
data = dataBuffer - 8;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t dest[100*2];
wmemset(dest, L'C', 100*2-1); 
dest[100*2-1] = L'\0'; 
wcscpy(dest, data);
printWLine(dest);
}
}
",0
3118,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(staticTrue)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncat(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",0
2998,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(1)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
memcpy(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
19461,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
goto source;
source:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
goto sink;
sink:
goodB2GVaSinkG(data, data);
}
",1
21969,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memcpy(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
22536,"void function()
{
wchar_t * data;
data = NULL;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
",1
18613,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
19134,"void function()
{
if(STATIC_CONST_TRUE)
{
{
charVoid structCharVoid;
structCharVoid.voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid.voidSecond);
memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid.charFirst);
printLine((char *)structCharVoid.voidSecond);
}
}
}
",1
22942,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE==5)
{
fscanf(stdin, ""%d"", &data);
}
if(STATIC_CONST_FIVE==5)
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
15043,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
{
wchar_t * data = *dataPtr1;
data = dataBuffer;
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
}
",1
16901,"void function()
{
char * data;
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_char_cpy_34_unionType myUnion;
data = NULL;
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
free(data);
}
}
}
",1
4554,"void function()
{
int data;
data = -1;
if(globalFive==5)
{
data = RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
2387,"void function()
{
int data;
data = -1;
if(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
10037,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(globalReturnsTrue())
{
goodG2B1VaSinkB(data, data);
}
}
",1
19582,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
goodB2GVaSink(data, data);
}
",1
20836,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticTrue)
{
data = dataBuffer;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
",1
7910,"void function()
{
char * data;
data = NULL;
switch(6)
{
case 6:
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",0
6764,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_TRUE)
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
}
}
}
",0
18950,"void function()
{
char * data;
data = NULL;
if(GLOBAL_CONST_FIVE==5)
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
SNPRINTF(data, 100, ""%s"", source);
printLine(data);
free(data);
}
}
",1
15037,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
11521,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
wcscpy(data, L""fixedstringtest"");
}
if(staticReturnsTrue())
{
goodG2B2VaSinkB(data, data);
}
}
",1
18586,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t dest[100*2];
wmemset(dest, L'C', 100*2-1); 
dest[100*2-1] = L'\0'; 
wcscpy(dest, data);
printWLine(dest);
}
}
",1
11310,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataGoodBuffer;
data[0] = L'\0'; 
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",1
2773,"void function()
{
int data;
data = -1;
if(globalReturnsTrue())
{
data = RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
14189,"void function()
{
int data;
data = -1;
if(5==5)
{
data = RAND32();
}
if(5==5)
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
free(buffer);
}
}
}
",1
19581,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(GLOBAL_CONST_FIVE==5)
{
data = dataBuffer;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
",1
11877,"void function()
{
wchar_t * data;
CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_vfprintf_34_unionType myUnion;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
wcscpy(data, L""fixedstringtest"");
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
goodG2BVaSink(data, data);
}
}
",1
1790,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
fwprintf(stdout, data);
}
}
",0
12836,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
16092,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
9633,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
data = dataBuffer;
break;
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
",1
1083,"void function()
{
short data;
data = 0;
if(GLOBAL_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
8674,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
12391,"void function()
{
char * data;
data = NULL;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
{
char * dataCopy = data;
char * data = dataCopy;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
}
",1
12896,"void function()
{
int h;
int * data;
int dataBadBuffer[50];
int dataGoodBuffer[100];
for(h = 0; h < 1; h++)
{
data = dataGoodBuffer;
}
{
int source[100] = {0}; 
memcpy(data, source, 100*sizeof(int));
printIntLine(data[0]);
}
}
",1
3168,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(GLOBAL_CONST_FIVE==5)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = strlen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printLine(data);
}
}
",0
82,"void function()
{
int i;
twoIntsStruct * data;
data = NULL;
for(i = 0; i < 1; i++)
{
data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
free(data);
}
}
",0
12518,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscat(dest, data);
printWLine(data);
}
}
",1
18127,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(globalFive==5)
{
data = dataGoodBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memmove(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
11264,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_TRUE)
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
16865,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
SNPRINTF(dest, wcslen(data), L""%s"", data);
printWLine(data);
free(data);
}
}
",1
19896,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
{
wchar_t * data = *dataPtr1;
data = dataGoodBuffer;
data[0] = L'\0'; 
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncat(data, source, 100);
printWLine(data);
}
}
}
",1
22773,"void function()
{
int h;
int * data;
data = NULL;
for(h = 0; h < 1; h++)
{
data = (int *)ALLOCA(10*sizeof(int));
}
{
int source[10] = {0};
size_t i;
for (i = 0; i < 10; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
}
}
",1
19523,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
switch(6)
{
case 6:
data = dataBuffer;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char dest[100*2];
memset(dest, 'C', 100*2-1); 
dest[100*2-1] = '\0'; 
strcpy(dest, data);
printLine(dest);
}
}
",1
4227,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(GLOBAL_CONST_TRUE)
{
data = dataBuffer - 8;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",0
21234,"void function()
{
short data;
CWE194_Unexpected_Sign_Extension__fgets_strncpy_34_unionType myUnion;
data = 0;
data = 100-1;
myUnion.unionFirst = data;
{
short data = myUnion.unionSecond;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",1
11306,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_FIVE==5)
{
printf(""%s\n"", data);
}
}
",1
12051,"void function()
{
int * data;
data = NULL;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (int *)ALLOCA(10*sizeof(int));
}
{
int source[10] = {0};
memmove(data, source, 10*sizeof(int));
printIntLine(data[0]);
}
}
",1
20622,"void function()
{
twoIntsStruct * data;
twoIntsStruct dataBadBuffer[50];
twoIntsStruct dataGoodBuffer[100];
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printStructLine(&data[0]);
}
}
}
",1
9943,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(staticTrue)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
}
}
",1
21771,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
goto source;
source:
data = dataGoodBuffer;
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
21867,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
971,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
badVaSink(data, data);
}
",0
13758,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
19594,"void function()
{
int i,k;
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
for(i = 0; i < 1; i++)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
for(k = 0; k < 1; k++)
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
16970,"void function()
{
char * data;
data = NULL;
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
free(data);
}
}
",1
22115,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
wcscpy(data, L""fixedstringtest"");
}
if(staticReturnsTrue())
{
goodG2B2VaSinkB(data, data);
}
}
",1
15493,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
strncpy(dest, data, strlen(dest));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
2022,"void function()
{
int i,j;
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
for(i = 0; i < 1; i++)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
for(j = 0; j < 1; j++)
{
fprintf(stdout, data);
}
}
",0
17297,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(globalTrue)
{
wprintf(data);
}
}
",1
19321,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
if(staticReturnsTrue())
{
data = dataGoodBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memmove(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
9677,"void function()
{
short data;
data = 0;
while(1)
{
data = 100-1;
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
19838,"void function()
{
wchar_t * data;
data = NULL;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
8652,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
wprintf(L""%s\n"", data);
}
}
",1
19596,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(globalReturnsTrue())
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
3898,"void function()
{
int i;
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
for(i = 0; i < 1; i++)
{
data = dataBuffer - 8;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0';
printWLine(data);
}
}
",0
4766,"void function()
{
int64_t * data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
if(GLOBAL_CONST_FIVE==5)
{
data = dataBadBuffer;
}
{
int64_t source[100] = {0}; 
memmove(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",0
20090,"void function()
{
if(globalReturnsTrue())
{
{
charVoid structCharVoid;
structCharVoid.voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid.voidSecond);
memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid.charFirst);
printWLine((wchar_t *)structCharVoid.voidSecond);
}
}
}
",1
755,"void function()
{
int data;
data = -1;
while(1)
{
data = -1;
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
17584,"void function()
{
int data;
data = -1;
if(globalTrue)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
8348,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
data = dataGoodBuffer;
data[0] = '\0'; 
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
}
}
",1
18146,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(8)
{
case 7:
printLine(""Benign, fixed string"");
break;
default:
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
break;
}
}
",1
12913,"void function()
{
int * data;
int dataBadBuffer[50];
int dataGoodBuffer[100];
goto source;
source:
data = dataGoodBuffer;
{
int source[100] = {0}; 
memcpy(data, source, 100*sizeof(int));
printIntLine(data[0]);
}
}
",1
18605,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(globalTrue)
{
goodG2B1VaSinkB(data, data);
}
}
",1
22808,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(1)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
}
}
",1
10251,"void function()
{
int64_t * data;
int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
int64_t source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printLongLongLine(data[0]);
}
}
}
",1
23126,"void function()
{
int data;
data = -1;
if(globalFive==5)
{
data = RAND32();
}
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
10277,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(STATIC_CONST_TRUE)
{
goodG2B1VaSinkB(data, data);
}
}
",1
19464,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(1)
{
goodG2B1VaSinkB(data, data);
}
}
",1
4145,"void function()
{
short data;
data = 0;
while(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
11795,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
8598,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(staticFive==5)
{
goodG2B1VaSinkB(data, data);
}
}
",1
18917,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
strcpy(data, ""fixedstringtest"");
}
if(globalReturnsTrue())
{
goodG2B2VaSinkB(data, data);
}
}
",1
21356,"void function()
{
int data;
data = -1;
while(1)
{
data = RAND32();
break;
}
while(1)
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
break;
}
}
",1
21719,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalFive==5)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(globalFive==5)
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
1193,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
goto source;
source:
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
goto sink;
sink:
badVaSinkB(data, data);
}
",0
12702,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
22468,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
goto source;
source:
data = dataBuffer;
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
strncpy(dest, data, strlen(dest));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
6643,"void function()
{
int64_t * data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
if(GLOBAL_CONST_TRUE)
{
data = dataBadBuffer;
}
{
int64_t source[100] = {0}; 
memcpy(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",0
23106,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
switch(6)
{
case 6:
data = dataGoodBuffer;
data[0] = L'\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
}
}
",1
15268,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
goto source;
source:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
goto sink;
sink:
fwprintf(stdout, L""%s\n"", data);
}
",1
15593,"void function()
{
wchar_t * data;
data = NULL;
goto source;
source:
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
",1
1122,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(globalReturnsTrue())
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
free(data);
}
}
",0
21049,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
wprintf(L""%s\n"", data);
}
",1
3895,"void function()
{
int data;
data = -1;
if(staticTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
23182,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(GLOBAL_CONST_FIVE==5)
{
wprintf(data);
}
}
",1
10879,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
wcscpy(data, L""fixedstringtest"");
}
if(GLOBAL_CONST_TRUE)
{
goodG2B2VaSinkB(data, data);
}
}
",1
57,"void function()
{
char * data;
data = NULL;
goto source;
source:
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcat(data, source);
printLine(data);
free(data);
}
}
",0
1761,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
switch(6)
{
case 6:
data = dataBadBuffer;
data[0] = '\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
SNPRINTF(data, 100, ""%s"", source);
printLine(data);
}
}
",0
11753,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(GLOBAL_CONST_FIVE==5)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
12041,"void function()
{
wchar_t * data;
CWE124_Buffer_Underwrite__malloc_wchar_t_cpy_34_unionType myUnion;
data = NULL;
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
}
",1
6347,"void function()
{
wchar_t * data;
data = NULL;
if(5==5)
{
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncat(data, source, 100);
printWLine(data);
free(data);
}
}
",0
9802,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_TRUE)
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
9342,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticTrue)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(staticTrue)
{
goodB2G2VaSinkG(data, data);
}
}
",1
13141,"void function()
{
twoIntsStruct * data;
data = NULL;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
free(data);
}
}
",1
15195,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(STATIC_CONST_FIVE==5)
{
goodB2G2VaSinkG(data, data);
}
}
",1
12517,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",1
20149,"void function()
{
short data;
data = 0;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
15311,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE==5)
{
data = RAND32();
}
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
21617,"void function()
{
char * data;
data = NULL;
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
break;
}
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
free(data);
}
}
",1
2781,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(staticReturnsTrue())
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscat(dest, data);
printWLine(data);
free(data);
}
}
",0
1266,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
while(1)
{
data = dataBuffer - 8;
break;
}
{
wchar_t dest[100*2];
wmemset(dest, L'C', 100*2-1); 
dest[100*2-1] = L'\0'; 
wcscpy(dest, data);
printWLine(dest);
}
}
",0
10449,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(globalTrue)
{
wprintf(L""%s\n"", data);
}
}
",1
443,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(globalTrue)
{
badVaSinkB(data, data);
}
}
",0
9670,"void function()
{
short data;
data = 0;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
20856,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
strcpy(data, ""fixedstringtest"");
}
if(STATIC_CONST_TRUE)
{
goodG2B2VaSinkB(data, data);
}
}
",1
11621,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
3281,"void function()
{
int * data;
int dataBadBuffer[50];
int dataGoodBuffer[100];
if(STATIC_CONST_TRUE)
{
data = dataBadBuffer;
}
{
int source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
}
}
}
",0
5440,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
}
}
",0
7954,"void function()
{
twoIntsStruct * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
free(data);
}
}
",0
8054,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
switch(6)
{
case 6:
data = dataBuffer - 8;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
17000,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
4288,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100] = """";
data = dataBuffer;
{
char * data = *dataPtr1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
badVaSink(data, data);
}
}
",0
5342,"void function()
{
short data;
data = 0;
if(globalTrue)
{
data = (short)RAND32();
}
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
",0
14003,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
size_t i, dataLen;
dataLen = strlen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
12532,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(5==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
7789,"void function()
{
int data;
data = -1;
if(5==5)
{
fscanf(stdin, ""%d"", &data);
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
823,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(5==5)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
577,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive==5)
{
badVaSinkB(data, data);
}
}
",0
14735,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(globalTrue)
{
fprintf(stdout, data);
}
}
",1
7893,"void function()
{
char * data;
data = NULL;
if(globalReturnsTrue())
{
data = (char *)malloc(10*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
}
}
",0
1419,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
switch(6)
{
case 6:
data = dataBuffer - 8;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
",0
1039,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(staticReturnsTrue())
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
}
}
",0
4143,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
goto source;
source:
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
goto sink;
sink:
wprintf(data);
}
",0
9302,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
strcpy(data, ""fixedstringtest"");
break;
}
switch(7)
{
case 7:
goodG2B1VaSinkB(data, data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
15228,"void function()
{
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
char src[150], dest[100];
int i;
memset(src, 'A', 149);
src[149] = '\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
dest[99] = '\0'; 
printLine(dest);
}
}
}
",1
21400,"void function()
{
char * data;
data = NULL;
if(staticReturnsTrue())
{
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = strlen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printLine(data);
free(data);
}
}
",1
3157,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(staticTrue)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strncpy(data, source, strlen(source) + 1);
printLine(data);
}
}
",0
15484,"void function()
{
wchar_t * data;
data = NULL;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
4451,"void function()
{
int * data;
int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
if(GLOBAL_CONST_FIVE==5)
{
data = dataBadBuffer;
}
{
int source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
}
}
}
",0
7603,"void function()
{
wchar_t * data;
CWE127_Buffer_Underread__wchar_t_declare_ncpy_34_unionType myUnion;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
}
",0
10323,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(GLOBAL_CONST_FIVE==5)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",1
9901,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
wcscpy(data, L""fixedstringtest"");
}
if(STATIC_CONST_TRUE)
{
goodG2B2VaSinkB(data, data);
}
}
",1
14384,"void function()
{
wchar_t * data;
CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_vprintf_34_unionType myUnion;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
goodB2GVaSink(data, data);
}
}
",1
3520,"void function()
{
short data;
data = 0;
if(globalReturnsTrue())
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = (short)atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
15359,"void function()
{
int data;
data = -1;
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
18107,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
while(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
}
while(1)
{
goodB2GVaSinkG(data, data);
break;
}
}
",1
13183,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
SNPRINTF(dest, wcslen(data), L""%s"", data);
printWLine(data);
free(data);
}
}
",1
4966,"void function()
{
short data;
data = 0;
if(GLOBAL_CONST_TRUE)
{
data = (short)RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
16158,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
goto source;
source:
data = dataGoodBuffer;
data[0] = '\0'; 
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
}
}
",1
22183,"void function()
{
char * data;
data = NULL;
if(globalFive==5)
{
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
free(data);
}
}
",1
14269,"void function()
{
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
charVoid structCharVoid;
structCharVoid.voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid.voidSecond);
memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid.charFirst);
printWLine((wchar_t *)structCharVoid.voidSecond);
}
}
}
",1
18068,"void function()
{
int64_t * data;
data = NULL;
if(staticTrue)
{
data = (int64_t *)malloc(100*sizeof(int64_t));
if (data == NULL) {exit(-1);}
}
{
int64_t source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printLongLongLine(data[0]);
free(data);
}
}
}
",1
7518,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
switch(6)
{
case 6:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
fwprintf(stdout, data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",0
21295,"void function()
{
void * data;
data = NULL;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
char * dataGoodBuffer = (char *)malloc(50*sizeof(char));
if (dataGoodBuffer == NULL) {exit(-1);}
memset(dataGoodBuffer, 'A', 50-1);
dataGoodBuffer[50-1] = '\0';
data = (void *)dataGoodBuffer;
}
}
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
if (dest == NULL) {exit(-1);}
(void)strcpy(dest, data);
printLine((char *)dest);
free(dest);
}
}
}
",1
13789,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(staticFive==5)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",1
15010,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
strcpy(data, ""fixedstringtest"");
}
if(GLOBAL_CONST_FIVE==5)
{
printf(data);
}
}
",1
6608,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(globalReturnsTrue())
{
badVaSinkB(data, data);
}
}
",0
3564,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
char * dataCopy = data;
char * data = dataCopy;
badVaSink(data, data);
}
}
",0
19335,"void function()
{
int data;
data = -1;
data = RAND32();
{
int dataCopy = data;
int data = dataCopy;
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
6947,"void function()
{
int data;
data = -1;
goto source;
source:
data = -1;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
14071,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
while(1)
{
data = dataGoodBuffer;
break;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memmove(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
19536,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(5==5)
{
data = dataBuffer;
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
",1
17519,"void function()
{
short data;
data = 0;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
9686,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",1
4325,"void function()
{
wchar_t * data;
data = NULL;
data = (wchar_t *)malloc(10*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = wcslen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printWLine(data);
free(data);
}
}
}
",0
20122,"void function()
{
wchar_t * data;
data = NULL;
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memmove(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
",1
7029,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
{
wchar_t * data = *dataPtr1;
data = dataBuffer - 8;
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
}
",0
10001,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncat(data, source, 100);
printLine(data);
}
}
",1
13596,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
switch(6)
{
case 6:
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
1795,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(5==5)
{
data = dataBadBuffer;
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",0
3875,"void function()
{
int data;
data = -1;
if(globalReturnsTrue())
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(globalReturnsTrue())
{
{
int buffer[10] = { 0 };
if (data >= 0)
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is negative"");
}
}
}
}
",0
16802,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
while(1)
{
data = dataBuffer;
break;
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",1
4970,"void function()
{
wchar_t * data;
CWE127_Buffer_Underread__wchar_t_alloca_memmove_34_unionType myUnion;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memmove(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
}
",0
5025,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
7728,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
",0
1614,"void function()
{
wchar_t * data;
data = NULL;
if(globalReturnsTrue())
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",0
21644,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
size_t i, dataLen;
dataLen = strlen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
2285,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalFive==5)
{
data = dataBuffer - 8;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
17851,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(5==5)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
22039,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(STATIC_CONST_FIVE==5)
{
printf(data);
}
}
",1
3217,"void function()
{
int64_t * data;
data = NULL;
data = (int64_t *)malloc(50*sizeof(int64_t));
if (data == NULL) {exit(-1);}
{
int64_t source[100] = {0}; 
memmove(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
free(data);
}
}
",0
14207,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
{
char * dataCopy = data;
char * data = dataCopy;
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
}
",1
7680,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsTrue())
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
}
}
",0
17416,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
15983,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticTrue)
{
wcscpy(data, L""fixedstringtest"");
}
if(staticTrue)
{
fwprintf(stdout, data);
}
}
",1
7089,"void function()
{
short data;
data = 0;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
short dataCopy = data;
short data = dataCopy;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",0
203,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
goto source;
source:
data = dataBuffer - 8;
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",0
13890,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
goto source;
source:
data = dataGoodBuffer;
data[0] = L'\0'; 
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
19203,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
{
char * dataCopy = data;
char * data = dataCopy;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
}
",1
5289,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
{
wchar_t * data = *dataPtr1;
data = dataBadBuffer;
data[0] = L'\0'; 
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
}
",0
4850,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
badVaSink(data, data);
}
}
",0
1102,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticTrue)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
}
}
",0
3733,"void function()
{
short data;
data = 0;
if(STATIC_CONST_FIVE==5)
{
data = -1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
953,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(5==5)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(5==5)
{
badVaSinkB(data, data);
}
}
",0
13250,"void function()
{
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid->voidSecond);
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid->charFirst);
printWLine((wchar_t *)structCharVoid->voidSecond);
free(structCharVoid);
}
}
}
",1
14354,"void function()
{
twoIntsStruct * data;
twoIntsStruct dataBadBuffer[50];
twoIntsStruct dataGoodBuffer[100];
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printStructLine(&data[0]);
}
}
}
",1
14326,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
}
}
",1
16945,"void function()
{
char * data;
data = NULL;
if(STATIC_CONST_FIVE==5)
{
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
}
}
",1
7430,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncat(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",0
13058,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
11401,"void function()
{
char * data;
data = NULL;
if(GLOBAL_CONST_FIVE==5)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
char dest[100*2];
memset(dest, 'C', 100*2-1); 
dest[100*2-1] = '\0'; 
strcpy(dest, data);
printLine(dest);
}
}
",1
18225,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(5==5)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
6034,"void function()
{
int data;
data = -1;
fscanf(stdin, ""%d"", &data);
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
643,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
{
char * data = *dataPtr1;
data = dataBuffer - 8;
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
}
",0
3489,"void function()
{
int data;
data = -1;
if(STATIC_CONST_TRUE)
{
fscanf(stdin, ""%d"", &data);
}
if(STATIC_CONST_TRUE)
{
{
int i;
int buffer[10] = { 0 };
if (data < 10)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
}
}
}
",0
11769,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(staticFive==5)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
size_t i, dataLen;
dataLen = wcslen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
4901,"void function()
{
char * data;
data = NULL;
if(STATIC_CONST_FIVE==5)
{
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memcpy(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
free(data);
}
}
",0
109,"void function()
{
int data;
data = -1;
goto source;
source:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
11156,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalReturnsTrue())
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(globalReturnsTrue())
{
goodB2G2VaSinkG(data, data);
}
}
",1
21484,"void function()
{
char * data;
data = NULL;
if(globalFive==5)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",1
8876,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
memcpy(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
15520,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalReturnsTrue())
{
wcscpy(data, L""fixedstringtest"");
}
if(globalReturnsTrue())
{
goodG2B2VaSinkB(data, data);
}
}
",1
23104,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",1
1074,"void function()
{
int i;
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
for(i = 0; i < 1; i++)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",0
4725,"void function()
{
char * data;
CWE121_Stack_Based_Buffer_Overflow__CWE805_char_declare_snprintf_34_unionType myUnion;
char dataBadBuffer[50];
char dataGoodBuffer[100];
data = dataBadBuffer;
data[0] = '\0'; 
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
SNPRINTF(data, 100, ""%s"", source);
printLine(data);
}
}
}
",0
12038,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(staticFive==5)
{
fwprintf(stdout, data);
}
}
",1
15412,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
SNPRINTF(dest, strlen(data), ""%s"", data);
printLine(data);
}
}
",1
5900,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(globalTrue)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
SNPRINTF(data, 100, ""%s"", source);
printLine(data);
}
}
",0
9696,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsTrue())
{
goodB2G2VaSinkG(data, data);
}
}
",1
4867,"void function()
{
twoIntsStruct * data;
data = NULL;
if(GLOBAL_CONST_TRUE)
{
data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
free(data);
}
}
",0
17285,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
9596,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalReturnsTrue())
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
21045,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
data = dataGoodBuffer;
data[0] = L'\0'; 
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t source[10+1] = SRC_STRING;
memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
}
",1
243,"void function()
{
int * data;
data = NULL;
if(STATIC_CONST_FIVE==5)
{
data = (int *)malloc(10);
if (data == NULL) {exit(-1);}
}
{
int source[10] = {0};
size_t i;
for (i = 0; i < 10; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
free(data);
}
}
",0
9956,"void function()
{
wchar_t * data;
data = NULL;
if(GLOBAL_CONST_FIVE==5)
{
data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
free(data);
}
}
",1
18758,"void function()
{
int h;
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
for(h = 0; h < 1; h++)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memmove(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
20824,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5==5)
{
wcscpy(data, L""fixedstringtest"");
}
if(5==5)
{
wprintf(data);
}
}
",1
22985,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticTrue)
{
strcpy(data, ""fixedstringtest"");
}
if(staticTrue)
{
fprintf(stdout, data);
}
}
",1
14039,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
wprintf(L""%s\n"", data);
}
}
",1
16778,"void function()
{
int h;
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
for(h = 0; h < 1; h++)
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memmove(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
16207,"void function()
{
int data;
data = -1;
if(globalReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalReturnsTrue())
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
21874,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
19798,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(5==5)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(5==5)
{
goodB2G2VaSinkG(data, data);
}
}
",1
7830,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
data = dataBadBuffer;
data[0] = '\0'; 
{
char source[10+1] = SRC_STRING;
strncpy(data, source, strlen(source) + 1);
printLine(data);
}
}
",0
15883,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
22325,"void function()
{
void * data;
data = NULL;
while(1)
{
{
char * dataGoodBuffer = (char *)malloc(50*sizeof(char));
if (dataGoodBuffer == NULL) {exit(-1);}
memset(dataGoodBuffer, 'A', 50-1);
dataGoodBuffer[50-1] = '\0';
data = (void *)dataGoodBuffer;
}
break;
}
while(1)
{
{
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
if (dest == NULL) {exit(-1);}
(void)strcpy(dest, data);
printLine((char *)dest);
free(dest);
}
break;
}
}
",1
8163,"void function()
{
int i;
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
for(i = 0; i < 1; i++)
{
data = dataBuffer - 8;
}
{
char dest[100*2];
memset(dest, 'C', 100*2-1); 
dest[100*2-1] = '\0'; 
strcpy(dest, data);
printLine(dest);
}
}
",0
7528,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
while(1)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
break;
}
{
wchar_t dest[50] = L"""";
wcscat(dest, data);
printWLine(data);
free(data);
}
}
",0
16791,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(globalFive==5)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
free(data);
}
}
",1
20310,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
817,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticFive==5)
{
data = dataBuffer - 8;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
",0
7113,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(staticReturnsTrue())
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strncpy(data, source, strlen(source) + 1);
printLine(data);
}
}
",0
22685,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(GLOBAL_CONST_TRUE)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcpy(dest, data);
printLine(data);
free(data);
}
}
",1
18472,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
fwprintf(stdout, L""%s\n"", data);
}
}
",1
21845,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(STATIC_CONST_TRUE)
{
goodG2B1VaSinkB(data, data);
}
}
",1
4684,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(GLOBAL_CONST_TRUE)
{
data = dataBuffer - 8;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",0
12161,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(globalFive==5)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
}
}
",1
16142,"void function()
{
twoIntsStruct * data;
data = NULL;
if(staticReturnsTrue())
{
data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printStructLine(&data[0]);
free(data);
}
}
}
",1
17015,"void function()
{
wchar_t * data;
data = NULL;
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
",1
7377,"void function()
{
twoIntsStruct * data;
data = NULL;
goto source;
source:
data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printStructLine(&data[0]);
free(data);
}
}
}
",0
9599,"void function()
{
void * data;
data = NULL;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (void *)CHAR_STRING;
}
if(globalFive==5)
{
{
size_t dataLen = strlen((char *)data);
void * dest = (void *)ALLOCA((dataLen+1) * 1);
(void)strcpy(dest, data);
printLine((char *)dest);
}
}
}
",1
8017,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(globalTrue)
{
badVaSinkB(data, data);
}
}
",0
9883,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memmove(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
}
",1
7065,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(staticReturnsTrue())
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = strlen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printLine(data);
}
}
",0
17263,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
strcpy(data, ""fixedstringtest"");
goodG2BVaSink(data, data);
}
",1
5917,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(staticFive==5)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
SNPRINTF(dest, strlen(data), ""%s"", data);
printLine(data);
}
}
",0
9311,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(1)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strncpy(data, source, strlen(source) + 1);
printLine(data);
}
}
",1
23017,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(1)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",1
1801,"void function()
{
int data;
CWE195_Signed_to_Unsigned_Conversion_Error__listen_socket_strncpy_34_unionType myUnion;
data = -1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
myUnion.unionFirst = data;
{
int data = myUnion.unionSecond;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",0
16332,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(staticFive==5)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
}
}
",1
1329,"void function()
{
int i;
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
for(i = 0; i < 1; i++)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
memmove(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
14527,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FIVE==5)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
9029,"void function()
{
char * data;
data = NULL;
if(5==5)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
size_t i;
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",1
7710,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticTrue)
{
data = dataBuffer - 8;
}
{
size_t i;
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",0
4611,"void function()
{
wchar_t * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
599,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(STATIC_CONST_FIVE==5)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",0
8973,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
data = dataGoodBuffer;
data[0] = L'\0'; 
break;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncat(data, source, 100);
printWLine(data);
}
}
",1
1386,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
659,"void function()
{
int data;
data = -1;
if(5==5)
{
fscanf(stdin, ""%d"", &data);
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
1337,"void function()
{
short data;
data = 0;
if(STATIC_CONST_FIVE==5)
{
data = (short)RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
4653,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalReturnsTrue())
{
data = dataBuffer - 8;
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",0
2502,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
{
char * data = *dataPtr1;
data = dataBadBuffer;
data[0] = '\0'; 
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
}
}
}
",0
14437,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
SNPRINTF(dest, wcslen(data), L""%s"", data);
printWLine(data);
}
}
",1
9999,"void function()
{
short data;
data = 0;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
4531,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
switch(6)
{
case 6:
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char dest[50] = """";
strcpy(dest, data);
printLine(data);
free(data);
}
}
",0
9936,"void function()
{
short data;
data = 0;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
3348,"void function()
{
int data;
int *dataPtr1 = &data;
int *dataPtr2 = &data;
data = -1;
{
int data = *dataPtr1;
data = RAND32();
*dataPtr1 = data;
}
{
int data = *dataPtr2;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",0
15587,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
strcpy(data, ""fixedstringtest"");
}
if(1)
{
goodG2B2VaSinkB(data, data);
}
}
",1
10665,"void function()
{
char * data;
data = NULL;
goto source;
source:
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
{
char source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = strlen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printLine(data);
free(data);
}
}
",1
8847,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(GLOBAL_CONST_FIVE==5)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
}
}
",1
22539,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(1)
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
strncpy(dest, data, strlen(dest));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
534,"void function()
{
short data;
CWE194_Unexpected_Sign_Extension__listen_socket_strncpy_34_unionType myUnion;
data = 0;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
myUnion.unionFirst = data;
{
short data = myUnion.unionSecond;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",0
2875,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
switch(6)
{
case 6:
data = dataBadBuffer;
data[0] = '\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
}
}
",0
12465,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
22010,"void function()
{
int data;
data = -1;
if(globalFive==5)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
20507,"void function()
{
int data;
int *dataPtr1 = &data;
int *dataPtr2 = &data;
data = -1;
{
int data = *dataPtr1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
*dataPtr1 = data;
}
{
int data = *dataPtr2;
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
19048,"void function()
{
int * data;
data = NULL;
if(GLOBAL_CONST_FIVE==5)
{
data = (int *)malloc(10*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[10] = {0};
size_t i;
for (i = 0; i < 10; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
free(data);
}
}
",1
20519,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
size_t i;
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
}
",1
12969,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(8)
{
case 7:
printLine(""Benign, fixed string"");
break;
default:
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
break;
}
}
",1
9942,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalFive==5)
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
4485,"void function()
{
wchar_t * data;
data = NULL;
switch(6)
{
case 6:
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",0
6160,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(staticReturnsTrue())
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscat(data, source);
printWLine(data);
}
}
",0
8430,"void function()
{
void * data;
data = NULL;
if(staticTrue)
{
data = (void *)CHAR_STRING;
}
if(staticTrue)
{
{
size_t dataLen = strlen((char *)data);
void * dest = (void *)ALLOCA((dataLen+1) * 1);
(void)strcpy(dest, data);
printLine((char *)dest);
}
}
}
",1
15961,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(1)
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
21371,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
9846,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(globalReturnsTrue())
{
goodG2B1VaSinkB(data, data);
}
}
",1
4405,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
goto source;
source:
data = dataBadBuffer;
data[0] = '\0'; 
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",0
22165,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
strcpy(data, ""fixedstringtest"");
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
",1
3510,"void function()
{
short data;
data = 0;
if(staticTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
7011,"void function()
{
int data;
data = -1;
while(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
18350,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(staticFive==5)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
11906,"void function()
{
wchar_t * data;
data = NULL;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
",1
15237,"void function()
{
wchar_t * data;
CWE134_Uncontrolled_Format_String__wchar_t_listen_socket_printf_34_unionType myUnion;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
wprintf(L""%s\n"", data);
}
}
",1
7986,"void function()
{
wchar_t * data;
data = NULL;
goto source;
source:
data = (wchar_t *)malloc(10*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
free(data);
}
}
",0
11702,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
goto source;
source:
data = dataGoodBuffer;
data[0] = '\0'; 
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcat(data, source);
printLine(data);
}
}
",1
338,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(globalTrue)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",0
22672,"void function()
{
wchar_t * data;
data = NULL;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
",1
452,"void function()
{
int i;
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
for(i = 0; i < 1; i++)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
",0
16266,"void function()
{
int64_t * data;
int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
if(1)
{
data = dataGoodBuffer;
}
{
int64_t source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printLongLongLine(data[0]);
}
}
}
",1
20747,"void function()
{
char * data;
data = NULL;
if(staticReturnsTrue())
{
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
}
}
",1
17823,"void function()
{
int data;
data = -1;
if(globalReturnsTrue())
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
7257,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
if(staticTrue)
{
data = dataBadBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memmove(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
2232,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
if(GLOBAL_CONST_FIVE==5)
{
data = dataBadBuffer;
}
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
15732,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(globalTrue)
{
goodB2G2VaSinkG(data, data);
}
}
",1
18634,"void function()
{
int data;
data = -1;
if(5==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(5==5)
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
12895,"void function()
{
short data;
data = 0;
if(GLOBAL_CONST_FIVE==5)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
4114,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
switch(6)
{
case 6:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
printf(data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",0
1838,"void function()
{
wchar_t * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0';
printWLine(data);
}
}
",0
5709,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE==5)
{
data = -1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
19076,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
free(data);
}
}
",1
524,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(staticReturnsTrue())
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncat(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",0
1407,"void function()
{
short data;
CWE194_Unexpected_Sign_Extension__rand_malloc_34_unionType myUnion;
data = 0;
data = (short)RAND32();
myUnion.unionFirst = data;
{
short data = myUnion.unionSecond;
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
}
",0
19853,"void function()
{
char * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
char dest[100*2];
memset(dest, 'C', 100*2-1); 
dest[100*2-1] = '\0'; 
strcpy(dest, data);
printLine(dest);
}
}
",1
926,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(globalFive==5)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
SNPRINTF(data, 100, L""%s"", source);
printWLine(data);
}
}
",0
17412,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
switch(6)
{
case 6:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(8)
{
case 7:
printLine(""Benign, fixed string"");
break;
default:
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
break;
}
}
",1
9006,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticTrue)
{
wcscpy(data, L""fixedstringtest"");
}
if(staticTrue)
{
wprintf(data);
}
}
",1
22663,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",1
9020,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
22261,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
{
wchar_t dest[50] = L"""";
wcsncat(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
11081,"void function()
{
int data;
data = -1;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
2009,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
while(1)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
break;
}
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",0
22929,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
",1
12354,"void function()
{
int h;
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
for(h = 0; h < 1; h++)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
memmove(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
15835,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
memmove(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
8994,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memmove(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
9018,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE==5)
{
data = RAND32();
}
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
21123,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsTrue())
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
printf(""%s\n"", data);
}
}
",1
19491,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_TRUE)
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
12745,"void function()
{
wchar_t * data;
data = NULL;
data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
free(data);
}
}
",1
7894,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalReturnsTrue())
{
data = dataBuffer - 8;
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
",0
12897,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
16568,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
2244,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(globalFive==5)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",0
6291,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalTrue)
{
data = dataBuffer - 8;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
5418,"void function()
{
wchar_t * data;
data = NULL;
switch(6)
{
case 6:
data = (wchar_t *)malloc(10*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = wcslen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printWLine(data);
free(data);
}
}
",0
3298,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
printf(data);
}
}
",0
898,"void function()
{
short data;
data = 0;
goto source;
source:
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = (short)atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
23162,"void function()
{
int * data;
data = NULL;
if(STATIC_CONST_FIVE==5)
{
data = (int *)malloc(10*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[10] = {0};
size_t i;
for (i = 0; i < 10; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
free(data);
}
}
",1
22161,"void function()
{
wchar_t * data;
data = NULL;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memmove(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
",1
12775,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memmove(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
20697,"void function()
{
void * data;
data = NULL;
if(STATIC_CONST_FIVE==5)
{
{
wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
if (dataBadBuffer == NULL) {exit(-1);}
wmemset(dataBadBuffer, L'A', 50-1);
dataBadBuffer[50-1] = L'\0';
data = (void *)dataBadBuffer;
}
}
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
size_t dataLen = wcslen((wchar_t *)data);
void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
if (dest == NULL) {exit(-1);}
(void)wcscpy(dest, data);
printWLine((wchar_t *)dest);
free(dest);
}
}
}
",1
2179,"void function()
{
int i;
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
for(i = 0; i < 1; i++)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
SNPRINTF(data, 100, ""%s"", source);
printLine(data);
}
}
",0
21458,"void function()
{
short data;
data = 0;
goto source;
source:
data = 100-1;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
21993,"void function()
{
if(staticTrue)
{
{
wchar_t src[150], dest[100];
int i;
wmemset(src, L'A', 149);
src[149] = L'\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
dest[99] = L'\0'; 
printWLine(dest);
}
}
}
",1
15472,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
22634,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
goodB2G2VaSinkG(data, data);
}
}
",1
10671,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(staticReturnsTrue())
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
free(buffer);
}
}
}
",1
15705,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(STATIC_CONST_TRUE)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",1
1089,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
11183,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
",1
3685,"void function()
{
char * data;
data = NULL;
if(staticReturnsTrue())
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
}
{
size_t i;
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",0
6284,"void function()
{
wchar_t * data;
CWE124_Buffer_Underwrite__wchar_t_declare_loop_34_unionType myUnion;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
}
",0
21497,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
goto source;
source:
data = dataBuffer;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",1
15095,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
wprintf(L""%s\n"", data);
}
}
",1
5606,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(GLOBAL_CONST_FIVE==5)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0'; 
printLine(data);
}
}
",0
22152,"void function()
{
wchar_t * data;
data = NULL;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
17651,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
}
",1
9070,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_FIVE==5)
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
11739,"void function()
{
short data;
data = 0;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
1530,"void function()
{
int i,j;
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
for(i = 0; i < 1; i++)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
for(j = 0; j < 1; j++)
{
badVaSinkB(data, data);
}
}
",0
21848,"void function()
{
int h;
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
for(h = 0; h < 1; h++)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
}
}
",1
9398,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(STATIC_CONST_TRUE)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",1
6115,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(STATIC_CONST_FIVE==5)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",0
18370,"void function()
{
short data;
data = 0;
if(globalFive==5)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
15038,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
}
}
",1
2360,"void function()
{
wchar_t * data;
data = NULL;
if(GLOBAL_CONST_FIVE==5)
{
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",0
594,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
if(globalReturnsTrue())
{
data = dataBadBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memmove(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
598,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_TRUE)
{
badVaSinkB(data, data);
}
}
",0
1399,"void function()
{
int64_t * data;
int64_t * *dataPtr1 = &data;
int64_t * *dataPtr2 = &data;
int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
{
int64_t * data = *dataPtr1;
data = dataBadBuffer;
*dataPtr1 = data;
}
{
int64_t * data = *dataPtr2;
{
int64_t source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printLongLongLine(data[0]);
}
}
}
}
",0
12975,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
}
}
",1
3648,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(1)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",0
6247,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(1)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
}
}
",0
17686,"void function()
{
twoIntsStruct * data;
twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
if(staticReturnsTrue())
{
data = dataGoodBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",1
9077,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(globalTrue)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = strlen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printLine(data);
}
}
",1
14019,"void function()
{
twoIntsStruct * data;
twoIntsStruct dataBadBuffer[50];
twoIntsStruct dataGoodBuffer[100];
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",1
4628,"void function()
{
short data;
data = 0;
if(globalFive==5)
{
fscanf (stdin, ""%hd"", &data);
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
11816,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
}
}
",1
14274,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
switch(6)
{
case 6:
data = dataBuffer;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
16725,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(GLOBAL_CONST_TRUE)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
SNPRINTF(dest, wcslen(data), L""%s"", data);
printWLine(data);
free(data);
}
}
",1
5734,"void function()
{
int data;
data = -1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
16019,"void function()
{
char * data;
data = NULL;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcat(data, source);
printLine(data);
free(data);
}
}
",1
20066,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticTrue)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
679,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
data = NULL;
{
char * data = *dataPtr1;
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcat(data, source);
printLine(data);
free(data);
}
}
}
",0
242,"void function()
{
int data;
int *dataPtr1 = &data;
int *dataPtr2 = &data;
data = -1;
{
int data = *dataPtr1;
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
*dataPtr1 = data;
}
{
int data = *dataPtr2;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",0
22107,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",1
10175,"void function()
{
int data;
data = -1;
if(staticTrue)
{
data = RAND32();
}
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
free(buffer);
}
}
}
",1
809,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive==5)
{
badVaSinkB(data, data);
}
}
",0
22849,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
switch(6)
{
case 6:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
wprintf(L""%s\n"", data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
12955,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(staticTrue)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
",1
12403,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticTrue)
{
strcpy(data, ""fixedstringtest"");
}
if(staticTrue)
{
fprintf(stdout, data);
}
}
",1
8295,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100] = """";
data = dataBuffer;
{
char * data = *dataPtr1;
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
8223,"void function()
{
char * data;
data = NULL;
if(staticFive==5)
{
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",0
3279,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
}
",0
11419,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(globalTrue)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
SNPRINTF(data, 100, ""%s"", source);
printLine(data);
}
}
",1
6529,"void function()
{
short data;
data = 0;
goto source;
source:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
19691,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
}
}
}
",1
4885,"void function()
{
int data;
data = -1;
goto source;
source:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
13222,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FIVE==5)
{
fscanf(stdin, ""%d"", &data);
}
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
11669,"void function()
{
wchar_t * data;
data = NULL;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
1570,"void function()
{
wchar_t * data;
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_snprintf_34_unionType myUnion;
data = NULL;
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
SNPRINTF(data, 100, L""%s"", source);
printWLine(data);
free(data);
}
}
}
",0
22563,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(STATIC_CONST_TRUE)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
SNPRINTF(data, 100, L""%s"", source);
printWLine(data);
}
}
",1
22633,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
size_t i, dataLen;
dataLen = strlen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
11709,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
printf(""%s\n"", data);
}
}
",1
2044,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
8362,"void function()
{
int * data;
data = NULL;
if(globalFive==5)
{
data = (int *)malloc(10*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[10] = {0};
memcpy(data, source, 10*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",1
17034,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5==5)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
18240,"void function()
{
char * data;
data = NULL;
if(globalFive==5)
{
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
}
}
",1
3931,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(GLOBAL_CONST_FIVE==5)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
size_t i, dataLen;
dataLen = wcslen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",0
21152,"void function()
{
int data;
data = -1;
if(globalFive==5)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
18899,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100] = """";
data = dataBuffer;
{
char * data = *dataPtr1;
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
fprintf(stdout, ""%s\n"", data);
}
}
",1
4612,"void function()
{
short data;
data = 0;
switch(6)
{
case 6:
data = (short)RAND32();
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
19735,"void function()
{
int data;
data = -1;
if(globalReturnsTrue())
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(globalReturnsTrue())
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
13458,"void function()
{
wchar_t * data;
data = NULL;
goto source;
source:
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
SNPRINTF(data, 100, L""%s"", source);
printWLine(data);
free(data);
}
}
",1
12211,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcpy(dest, data);
printLine(data);
}
}
",1
13443,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
strcpy(data, ""fixedstringtest"");
}
if(1)
{
goodG2B2VaSinkB(data, data);
}
}
",1
7618,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FIVE==5)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
8563,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
wchar_t * data = *dataPtr1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
10129,"void function()
{
wchar_t * data;
data = NULL;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
14801,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
while(1)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
break;
}
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
7478,"void function()
{
void * data;
data = NULL;
if(STATIC_CONST_FIVE==5)
{
data = (void *)WIDE_STRING;
}
if(STATIC_CONST_FIVE==5)
{
{
size_t dataLen = strlen((char *)data);
void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
(void)wcscpy(dest, data);
printLine((char *)dest);
}
}
}
",0
9188,"void function()
{
wchar_t * data;
CWE134_Uncontrolled_Format_String__wchar_t_connect_socket_snprintf_34_unionType myUnion;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
13733,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFive==5)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
3305,"void function()
{
wchar_t * data;
data = NULL;
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memcpy(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
21090,"void function()
{
char * data;
data = NULL;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
",1
14480,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(GLOBAL_CONST_TRUE)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
SNPRINTF(data, 100, L""%s"", source);
printWLine(data);
}
}
",1
17549,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(staticTrue)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
}
}
",1
21516,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsTrue())
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticReturnsTrue())
{
goodB2G2VaSinkG(data, data);
}
}
",1
14362,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
SNPRINTF(data, 100, ""%s"", source);
printLine(data);
}
}
",1
2938,"void function()
{
if(globalFive==5)
{
{
wchar_t src[150], dest[100];
int i;
wmemset(src, L'A', 149);
src[149] = L'\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
printWLine(dest);
}
}
}
",0
19842,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(1)
{
data = dataBuffer;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",1
14950,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticTrue)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
1346,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
switch(6)
{
case 6:
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t dest[50] = L"""";
wcscat(dest, data);
printWLine(data);
}
}
",0
2064,"void function()
{
int data;
data = -1;
if(STATIC_CONST_TRUE)
{
data = RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
1049,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(GLOBAL_CONST_TRUE)
{
badVaSinkB(data, data);
}
}
",0
2204,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
8390,"void function()
{
int * data;
data = NULL;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (int *)ALLOCA(10*sizeof(int));
}
{
int source[10] = {0};
memcpy(data, source, 10*sizeof(int));
printIntLine(data[0]);
}
}
",1
14496,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(globalTrue)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
free(data);
}
}
",1
13511,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(5==5)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",1
237,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100] = """";
data = dataBuffer;
{
char * data = *dataPtr1;
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
fprintf(stdout, data);
}
}
",0
18717,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(1)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0'; 
printLine(data);
}
}
",1
18339,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalReturnsTrue())
{
wcscpy(data, L""fixedstringtest"");
}
if(globalReturnsTrue())
{
goodG2B2VaSinkB(data, data);
}
}
",1
20582,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(staticTrue)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscat(dest, data);
printWLine(data);
}
}
",1
2111,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalReturnsTrue())
{
fprintf(stdout, data);
}
}
",0
3201,"void function()
{
char * data;
data = NULL;
if(staticFive==5)
{
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",0
15946,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(staticReturnsTrue())
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcat(data, source);
printLine(data);
}
}
",1
10788,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticTrue)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
18119,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FIVE==5)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
14553,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
free(data);
}
}
",1
3999,"void function()
{
short data;
data = 0;
if(staticReturnsTrue())
{
data = (short)RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
13879,"void function()
{
twoIntsStruct * data;
twoIntsStruct dataBadBuffer[50];
twoIntsStruct dataGoodBuffer[100];
if(staticTrue)
{
data = dataGoodBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",1
12091,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
15643,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(staticTrue)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
14301,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
while(1)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
break;
}
{
wchar_t dest[50] = L"""";
memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
5073,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
goto source;
source:
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
}
}
",0
11416,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
3360,"void function()
{
int i;
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
for(i = 0; i < 1; i++)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
}
}
",0
6092,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(staticFive==5)
{
fwprintf(stdout, data);
}
}
",0
17193,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(STATIC_CONST_FIVE==5)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",1
18924,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
while(1)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
break;
}
{
wchar_t dest[50] = L"""";
memmove(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
1151,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(staticReturnsTrue())
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
size_t i, dataLen;
dataLen = wcslen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",0
16304,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(STATIC_CONST_TRUE)
{
goodG2B1VaSinkB(data, data);
}
}
",1
16946,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsTrue())
{
strcpy(data, ""fixedstringtest"");
}
if(staticReturnsTrue())
{
goodG2B2VaSinkB(data, data);
}
}
",1
9921,"void function()
{
wchar_t * data;
data = NULL;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0';
printWLine(data);
}
}
",1
17981,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
23066,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
data = dataGoodBuffer;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
9165,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncat(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
5469,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(1)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",0
1140,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_FIVE==5)
{
badVaSinkB(data, data);
}
}
",0
18772,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
wchar_t * data = *dataPtr1;
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
goodB2GVaSink(data, data);
}
}
",1
480,"void function()
{
if(STATIC_CONST_TRUE)
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid->voidSecond);
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(*structCharVoid));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid->charFirst);
printWLine((wchar_t *)structCharVoid->voidSecond);
free(structCharVoid);
}
}
}
",0
3911,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticTrue)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(staticTrue)
{
badVaSinkB(data, data);
}
}
",0
7073,"void function()
{
short data;
data = 0;
if(STATIC_CONST_TRUE)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = (short)atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
12935,"void function()
{
char * data;
data = NULL;
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
{
char * dataCopy = data;
char * data = dataCopy;
{
char source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = strlen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printLine(data);
free(data);
}
}
}
",1
9424,"void function()
{
short data;
data = 0;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
9581,"void function()
{
int64_t * data;
data = NULL;
if(globalTrue)
{
data = (int64_t *)malloc(100*sizeof(int64_t));
if (data == NULL) {exit(-1);}
}
{
int64_t source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printLongLongLine(data[0]);
free(data);
}
}
}
",1
5192,"void function()
{
int data;
data = -1;
if(STATIC_CONST_TRUE)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(STATIC_CONST_TRUE)
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
}
}
}
",0
1438,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(GLOBAL_CONST_TRUE)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
free(data);
}
}
",0
16635,"void function()
{
int64_t * data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
int64_t source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printLongLongLine(data[0]);
}
}
}
",1
5921,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(STATIC_CONST_FIVE==5)
{
data = dataBadBuffer;
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",0
7958,"void function()
{
wchar_t * data;
data = NULL;
switch(6)
{
case 6:
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",0
6021,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalReturnsTrue())
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",0
20023,"void function()
{
char * data;
data = NULL;
switch(6)
{
case 6:
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
5869,"void function()
{
wchar_t * data;
CWE122_Heap_Based_Buffer_Overflow__c_CWE193_wchar_t_cpy_34_unionType myUnion;
data = NULL;
data = (wchar_t *)malloc(10*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
free(data);
}
}
}
",0
10372,"void function()
{
char * data;
data = NULL;
if(1)
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncat(data, source, 100);
printLine(data);
free(data);
}
}
",1
19892,"void function()
{
char * data;
data = NULL;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
SNPRINTF(data, 100, ""%s"", source);
printLine(data);
free(data);
}
}
",1
22371,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
printf(""%s\n"", data);
}
}
",1
15834,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
5504,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(staticFive==5)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
memcpy(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
7988,"void function()
{
int data;
CWE127_Buffer_Underread__CWE839_fscanf_34_unionType myUnion;
data = -1;
fscanf(stdin, ""%d"", &data);
myUnion.unionFirst = data;
{
int data = myUnion.unionSecond;
{
int buffer[10] = { 0 };
if (data < 10)
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is too big."");
}
}
}
}
",0
17414,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
if(STATIC_CONST_TRUE)
{
data = dataGoodBuffer;
}
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
14807,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(GLOBAL_CONST_TRUE)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strncpy(data, source, strlen(source) + 1);
printLine(data);
}
}
",1
56,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
{
char * data = *dataPtr1;
data = dataBuffer - 8;
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
}
",0
20176,"void function()
{
void * data;
data = NULL;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = (void *)CHAR_STRING;
}
if(staticReturnsTrue())
{
{
size_t dataLen = strlen((char *)data);
void * dest = (void *)ALLOCA((dataLen+1) * 1);
(void)strcpy(dest, data);
printLine((char *)dest);
}
}
}
",1
4651,"void function()
{
short data;
data = 0;
if(globalFive==5)
{
data = -1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
2624,"void function()
{
char * data;
CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_loop_34_unionType myUnion;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
data = dataBadBuffer;
data[0] = '\0'; 
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
{
char source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = strlen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printLine(data);
}
}
}
",0
11244,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(STATIC_CONST_FIVE==5)
{
goodG2B1VaSinkB(data, data);
}
}
",1
22423,"void function()
{
int64_t * data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
int64_t source[100] = {0}; 
memcpy(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",1
4235,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(5==5)
{
data = dataBuffer - 8;
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
",0
14702,"void function()
{
int * data;
int dataBadBuffer[50];
int dataGoodBuffer[100];
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
int source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
}
}
}
",1
3841,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(staticFive==5)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
SNPRINTF(data, 100, ""%s"", source);
printLine(data);
}
}
",0
19079,"void function()
{
char * data;
data = NULL;
if(globalTrue)
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
free(data);
}
}
",1
5541,"void function()
{
wchar_t * data;
data = NULL;
while(1)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
break;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",0
10420,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalReturnsTrue())
{
goodB2G2VaSinkG(data, data);
}
}
",1
2856,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(globalTrue)
{
badVaSinkB(data, data);
}
}
",0
12645,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(GLOBAL_CONST_FIVE==5)
{
data = dataBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
21315,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticTrue)
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
strncpy(dest, data, strlen(dest));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
12688,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
4858,"void function()
{
twoIntsStruct * data;
twoIntsStruct dataBadBuffer[50];
twoIntsStruct dataGoodBuffer[100];
switch(6)
{
case 6:
data = dataBadBuffer;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",0
20600,"void function()
{
int h,j;
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
for(h = 0; h < 1; h++)
{
strcpy(data, ""fixedstringtest"");
}
for(j = 0; j < 1; j++)
{
fprintf(stdout, data);
}
}
",1
2352,"void function()
{
int i,j;
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
for(i = 0; i < 1; i++)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
for(j = 0; j < 1; j++)
{
fwprintf(stdout, data);
}
}
",0
19191,"void function()
{
void * data;
data = NULL;
if(globalReturnsTrue())
{
{
wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
if (dataBadBuffer == NULL) {exit(-1);}
wmemset(dataBadBuffer, L'A', 50-1);
dataBadBuffer[50-1] = L'\0';
data = (void *)dataBadBuffer;
}
}
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
{
size_t dataLen = wcslen((wchar_t *)data);
void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
if (dest == NULL) {exit(-1);}
(void)wcscpy(dest, data);
printWLine((wchar_t *)dest);
free(dest);
}
}
}
",1
3582,"void function()
{
wchar_t * data;
data = NULL;
if(staticReturnsTrue())
{
data = (wchar_t *)malloc(10*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
free(data);
}
}
",0
17444,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
{
wchar_t * data = *dataPtr1;
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t dest[50] = L"""";
memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
}
",1
18426,"void function()
{
int64_t * data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
int64_t source[100] = {0}; 
memcpy(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",1
18872,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
8502,"void function()
{
void * data;
data = NULL;
if(staticTrue)
{
data = (void *)WIDE_STRING;
}
if(staticTrue)
{
{
size_t dataLen = wcslen((wchar_t *)data);
void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
(void)wcscpy(dest, data);
printWLine((wchar_t *)dest);
}
}
}
",1
3899,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticReturnsTrue())
{
wprintf(data);
}
}
",0
1734,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
{
char * dataCopy = data;
char * data = dataCopy;
{
char dest[50] = """";
strcpy(dest, data);
printLine(data);
}
}
}
",0
4500,"void function()
{
int data;
CWE195_Signed_to_Unsigned_Conversion_Error__fgets_memmove_34_unionType myUnion;
data = -1;
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
myUnion.unionFirst = data;
{
int data = myUnion.unionSecond;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",0
20433,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(GLOBAL_CONST_TRUE)
{
printf(data);
}
}
",1
8743,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memmove(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
12622,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
19083,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(staticFive==5)
{
goodG2B1VaSinkB(data, data);
}
}
",1
8420,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
13554,"void function()
{
twoIntsStruct * data;
twoIntsStruct dataBadBuffer[50];
twoIntsStruct dataGoodBuffer[100];
if(GLOBAL_CONST_FIVE==5)
{
data = dataGoodBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memcpy(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",1
19396,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(globalFive==5)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
6918,"void function()
{
int data;
data = -1;
data = RAND32();
{
int dataCopy = data;
int data = dataCopy;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",0
4570,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
{
char * data = *dataPtr1;
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char dest[50] = """";
SNPRINTF(dest, strlen(data), ""%s"", data);
printLine(data);
free(data);
}
}
}
",0
9285,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(1)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
5053,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
goto source;
source:
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
goto sink;
sink:
badVaSinkB(data, data);
}
",0
9531,"void function()
{
void * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
{
wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
if (dataBadBuffer == NULL) {exit(-1);}
wmemset(dataBadBuffer, L'A', 50-1);
dataBadBuffer[50-1] = L'\0';
data = (void *)dataBadBuffer;
}
}
if(STATIC_CONST_TRUE)
{
{
size_t dataLen = wcslen((wchar_t *)data);
void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
if (dest == NULL) {exit(-1);}
(void)wcscpy(dest, data);
printWLine((wchar_t *)dest);
free(dest);
}
}
}
",1
19346,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
{
char * dataCopy = data;
char * data = dataCopy;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
}
",1
22565,"void function()
{
twoIntsStruct * data;
data = NULL;
if(staticReturnsTrue())
{
data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
free(data);
}
}
",1
16622,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",1
17507,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
9213,"void function()
{
char * data;
data = NULL;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
free(data);
}
}
",1
11462,"void function()
{
char * data;
data = NULL;
if(globalReturnsTrue())
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memmove(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
free(data);
}
}
",1
3896,"void function()
{
twoIntsStruct * data;
twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
if(1)
{
data = dataBadBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",0
3969,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(STATIC_CONST_FIVE==5)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",0
1306,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE==5)
{
fscanf(stdin, ""%d"", &data);
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
12338,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
switch(6)
{
case 6:
strcpy(data, ""fixedstringtest"");
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
printf(data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
19255,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
21654,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticFive==5)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
14462,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(globalFive==5)
{
fwprintf(stdout, data);
}
}
",1
11362,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalReturnsTrue())
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
wprintf(L""%s\n"", data);
}
}
",1
18942,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalFive==5)
{
data = dataBuffer;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",1
22458,"void function()
{
short data;
data = 0;
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
data = 100-1;
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
22361,"void function()
{
int64_t * data;
int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
if(STATIC_CONST_TRUE)
{
data = dataGoodBuffer;
}
{
int64_t source[100] = {0}; 
memcpy(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",1
21448,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(STATIC_CONST_FIVE==5)
{
data = dataBuffer;
}
{
wchar_t dest[100*2];
wmemset(dest, L'C', 100*2-1); 
dest[100*2-1] = L'\0'; 
wcscpy(dest, data);
printWLine(dest);
}
}
",1
20307,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0';
printWLine(data);
}
}
",1
15904,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memmove(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
2711,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(staticTrue)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0'; 
printLine(data);
}
}
",0
11883,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
}
}
",1
9052,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
strcpy(data, ""fixedstringtest"");
{
char * dataCopy = data;
char * data = dataCopy;
goodG2BVaSink(data, data);
}
}
",1
2262,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
switch(6)
{
case 6:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
badVaSinkB(data, data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",0
17616,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
char dest[100*2];
memset(dest, 'C', 100*2-1); 
dest[100*2-1] = '\0'; 
strcpy(dest, data);
printLine(dest);
}
}
",1
10173,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalReturnsTrue())
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
8125,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(STATIC_CONST_TRUE)
{
data = dataBuffer - 8;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",0
634,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalTrue)
{
data = dataBuffer - 8;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
2177,"void function()
{
int data;
data = -1;
if(globalFive==5)
{
data = RAND32();
}
if(globalFive==5)
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
}
}
}
",0
10605,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticTrue)
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
12752,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
SNPRINTF(data, 100, ""%s"", source);
printLine(data);
}
}
",1
13136,"void function()
{
int * data;
data = NULL;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (int *)malloc(100*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
free(data);
}
}
}
",1
8604,"void function()
{
int data;
data = -1;
if(1)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
5866,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalReturnsTrue())
{
fwprintf(stdout, data);
}
}
",0
18046,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
while(1)
{
strcpy(data, ""fixedstringtest"");
break;
}
while(1)
{
goodG2BVaSinkB(data, data);
break;
}
}
",1
16309,"void function()
{
while(1)
{
{
char data[150], dest[100];
memset(data, 'A', 149);
data[149] = '\0';
memcpy(dest, data, 99*sizeof(char));
dest[99] = '\0'; 
printLine(dest);
}
break;
}
}
",1
10606,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = wcslen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printWLine(data);
}
}
",1
7175,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsTrue())
{
printf(data);
}
}
",0
9167,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticFive==5)
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
6547,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
data = NULL;
{
char * data = *dataPtr1;
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
}
",0
15072,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
13869,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(staticReturnsTrue())
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
10328,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(staticFive==5)
{
fwprintf(stdout, data);
}
}
",1
20339,"void function()
{
int * data;
int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
if(STATIC_CONST_FIVE==5)
{
data = dataGoodBuffer;
}
{
int source[100] = {0}; 
memmove(data, source, 100*sizeof(int));
printIntLine(data[0]);
}
}
",1
1172,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(GLOBAL_CONST_TRUE)
{
data = dataBuffer - 8;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",0
19600,"void function()
{
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
{
charVoid structCharVoid;
structCharVoid.voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid.voidSecond);
memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid.charFirst);
printLine((char *)structCharVoid.voidSecond);
}
}
}
",1
11152,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
switch(6)
{
case 6:
data = dataBuffer;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
strncpy(dest, data, strlen(dest));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
9687,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
strcpy(data, ""fixedstringtest"");
}
if(1)
{
goodG2B2VaSinkB(data, data);
}
}
",1
23026,"void function()
{
int data;
data = -1;
if(1)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
13868,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
goto source;
source:
data = dataGoodBuffer;
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memcpy(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
19911,"void function()
{
wchar_t * data;
data = NULL;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
10285,"void function()
{
twoIntsStruct * data;
twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
if(5==5)
{
data = dataGoodBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printStructLine(&data[0]);
}
}
}
",1
4573,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(STATIC_CONST_FIVE==5)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",0
14213,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
data = dataGoodBuffer;
data[0] = '\0'; 
{
char * dataCopy = data;
char * data = dataCopy;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
}
}
}
",1
506,"void function()
{
int data;
data = -1;
if(globalFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
411,"void function()
{
int data;
data = -1;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
11980,"void function()
{
char * data;
data = NULL;
if(staticTrue)
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcat(data, source);
printLine(data);
free(data);
}
}
",1
10087,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(globalReturnsTrue())
{
goodG2B1VaSinkB(data, data);
}
}
",1
1529,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalReturnsTrue())
{
data = dataBuffer - 8;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memmove(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
7020,"void function()
{
char * data;
data = NULL;
if(5==5)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",0
5548,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(globalTrue)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0'; 
printWLine(data);
}
}
",0
9313,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(staticTrue)
{
goodG2B1VaSinkB(data, data);
}
}
",1
9027,"void function()
{
int h;
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
for(h = 0; h < 1; h++)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",1
19843,"void function()
{
short data;
data = 0;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
3570,"void function()
{
int data;
data = -1;
if(globalFive==5)
{
data = RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
17713,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
goto source;
source:
data = dataGoodBuffer;
data[0] = '\0'; 
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
}
}
",1
4226,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
data = NULL;
{
wchar_t * data = *dataPtr1;
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t dest[100*2];
wmemset(dest, L'C', 100*2-1); 
dest[100*2-1] = L'\0'; 
wcscpy(dest, data);
printWLine(dest);
}
}
}
",0
23116,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
if(STATIC_CONST_FIVE==5)
{
data = dataGoodBuffer;
}
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
12550,"void function()
{
twoIntsStruct * data;
twoIntsStruct dataBadBuffer[50];
twoIntsStruct dataGoodBuffer[100];
if(staticReturnsTrue())
{
data = dataGoodBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memcpy(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",1
19374,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memmove(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
14908,"void function()
{
wchar_t * data;
data = NULL;
if(globalTrue)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
size_t i;
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
3214,"void function()
{
short data;
data = 0;
if(STATIC_CONST_FIVE==5)
{
fscanf (stdin, ""%hd"", &data);
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
16799,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(STATIC_CONST_TRUE)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
}
}
",1
8845,"void function()
{
wchar_t * data;
data = NULL;
if(GLOBAL_CONST_TRUE)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
",1
765,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
char * dataCopy = data;
char * data = dataCopy;
badVaSink(data, data);
}
}
",0
3133,"void function()
{
char * data;
CWE127_Buffer_Underread__malloc_char_cpy_34_unionType myUnion;
data = NULL;
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
{
char dest[100*2];
memset(dest, 'C', 100*2-1); 
dest[100*2-1] = '\0'; 
strcpy(dest, data);
printLine(dest);
}
}
}
",0
1439,"void function()
{
{
charVoid structCharVoid;
structCharVoid.voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid.voidSecond);
memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid.charFirst);
printLine((char *)structCharVoid.voidSecond);
}
}
",0
2290,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(globalReturnsTrue())
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",0
16786,"void function()
{
char * data;
data = NULL;
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memcpy(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
free(data);
}
}
",1
14358,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(STATIC_CONST_TRUE)
{
printf(data);
}
}
",1
22308,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(staticTrue)
{
data = dataGoodBuffer;
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",1
7030,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
data = RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
16936,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(staticReturnsTrue())
{
wprintf(data);
}
}
",1
4373,"void function()
{
int data;
data = -1;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
14133,"void function()
{
wchar_t * data;
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_declare_ncat_34_unionType myUnion;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
data = dataGoodBuffer;
data[0] = L'\0'; 
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncat(data, source, 100);
printWLine(data);
}
}
}
",1
20830,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
2475,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(staticReturnsTrue())
{
badVaSinkB(data, data);
}
}
",0
15033,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t dest[100*2];
wmemset(dest, L'C', 100*2-1); 
dest[100*2-1] = L'\0'; 
wcscpy(dest, data);
printWLine(dest);
}
}
",1
11649,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_FIVE==5)
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
18901,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
data = RAND32();
}
if(staticReturnsTrue())
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
5598,"void function()
{
twoIntsStruct * data;
twoIntsStruct dataBadBuffer[50];
twoIntsStruct dataGoodBuffer[100];
if(staticReturnsTrue())
{
data = dataBadBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printStructLine(&data[0]);
}
}
}
",0
14284,"void function()
{
short data;
data = 0;
data = 100-1;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
15414,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(STATIC_CONST_TRUE)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = wcslen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printWLine(data);
}
}
",1
6876,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
SNPRINTF(dest, wcslen(data), L""%s"", data);
printWLine(data);
}
}
",0
3182,"void function()
{
int data;
data = -1;
data = RAND32();
{
int dataCopy = data;
int data = dataCopy;
{
int i;
int buffer[10] = { 0 };
if (data < 10)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
}
}
}
",0
18246,"void function()
{
int * data;
int dataBadBuffer[50];
int dataGoodBuffer[100];
if(globalTrue)
{
data = dataGoodBuffer;
}
{
int source[100] = {0}; 
memcpy(data, source, 100*sizeof(int));
printIntLine(data[0]);
}
}
",1
18238,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(GLOBAL_CONST_FIVE==5)
{
printf(data);
}
}
",1
7398,"void function()
{
int * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
data = (int *)malloc(50*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
free(data);
}
}
}
",0
1026,"void function()
{
int64_t * data;
int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
goto source;
source:
data = dataBadBuffer;
{
int64_t source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printLongLongLine(data[0]);
}
}
}
",0
16117,"void function()
{
wchar_t * data;
data = NULL;
if(staticFive==5)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
wchar_t dest[100*2];
wmemset(dest, L'C', 100*2-1); 
dest[100*2-1] = L'\0'; 
wcscpy(dest, data);
printWLine(dest);
}
}
",1
3524,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(globalTrue)
{
data = dataBadBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memcpy(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
875,"void function()
{
int i,j;
int data;
data = -1;
for(i = 0; i < 1; i++)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
for(j = 0; j < 1; j++)
{
{
int buffer[10] = { 0 };
if (data >= 0)
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is negative"");
}
}
}
}
",0
17014,"void function()
{
wchar_t * data;
CWE134_Uncontrolled_Format_String__wchar_t_environment_w32_vsnprintf_34_unionType myUnion;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
goodB2GVaSink(data, data);
}
}
",1
13649,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticTrue)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticTrue)
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
19642,"void function()
{
char * data;
data = NULL;
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
{
char * dataCopy = data;
char * data = dataCopy;
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
}
}
}
",1
5110,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(staticFive==5)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
memmove(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
9403,"void function()
{
int h;
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
for(h = 0; h < 1; h++)
{
data = dataBuffer;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",1
55,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_TRUE)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
}
}
",0
19866,"void function()
{
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t data[150], dest[100];
wmemset(data, L'A', 149);
data[149] = L'\0';
memcpy(dest, data, 99*sizeof(wchar_t));
dest[99] = L'\0'; 
printWLine(dest);
}
}
}
",1
22855,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcat(data, source);
printLine(data);
}
}
",1
2085,"void function()
{
char * data;
data = NULL;
if(GLOBAL_CONST_TRUE)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memmove(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
20451,"void function()
{
wchar_t * data;
CWE124_Buffer_Underwrite__wchar_t_declare_memmove_34_unionType myUnion;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
}
",1
3286,"void function()
{
short data;
data = 0;
switch(6)
{
case 6:
data = (short)RAND32();
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
4597,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(5==5)
{
data = dataBuffer - 8;
}
{
char dest[100*2];
memset(dest, 'C', 100*2-1); 
dest[100*2-1] = '\0'; 
strcpy(dest, data);
printLine(dest);
}
}
",0
22254,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
break;
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
11834,"void function()
{
char * data;
data = NULL;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
strncpy(data, source, strlen(source) + 1);
printLine(data);
free(data);
}
}
",1
20871,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(staticFive==5)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
}
}
",1
9980,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(1)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
}
}
",1
4258,"void function()
{
wchar_t * data;
data = NULL;
if(globalFive==5)
{
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",0
9245,"void function()
{
wchar_t * data;
data = NULL;
if(staticReturnsTrue())
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memmove(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
15671,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(GLOBAL_CONST_TRUE)
{
goodG2B1VaSinkB(data, data);
}
}
",1
6344,"void function()
{
int i,j;
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
for(i = 0; i < 1; i++)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
for(j = 0; j < 1; j++)
{
fprintf(stdout, data);
}
}
",0
11127,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",1
6107,"void function()
{
short data;
data = 0;
while(1)
{
data = (short)RAND32();
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
1762,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(STATIC_CONST_TRUE)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",0
22996,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
goodB2GVaSink(data, data);
}
",1
7249,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100];
data = dataBuffer;
{
char * data = *dataPtr1;
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
}
",0
1189,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
{
char * dataCopy = data;
char * data = dataCopy;
badVaSink(data, data);
}
}
",0
14893,"void function()
{
wchar_t * data;
CWE124_Buffer_Underwrite__wchar_t_alloca_ncpy_34_unionType myUnion;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0';
printWLine(data);
}
}
}
",1
636,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(STATIC_CONST_TRUE)
{
wprintf(data);
}
}
",0
14241,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(GLOBAL_CONST_FIVE==5)
{
goodG2B1VaSinkB(data, data);
}
}
",1
11792,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",1
17578,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = strlen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printLine(data);
}
}
",1
1980,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(5==5)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
}
}
",0
17568,"void function()
{
int data;
data = -1;
if(5==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(5==5)
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
17936,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(staticReturnsTrue())
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
}
}
",1
5826,"void function()
{
char * data;
data = NULL;
if(globalFive==5)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memmove(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
11602,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(staticTrue)
{
data = dataBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memcpy(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
3607,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(STATIC_CONST_TRUE)
{
data = dataBuffer - 8;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",0
2923,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(STATIC_CONST_TRUE)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0'; 
printWLine(data);
}
}
",0
9005,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
data = dataGoodBuffer;
data[0] = L'\0'; 
break;
}
{
wchar_t source[10+1] = SRC_STRING;
memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
",1
1819,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
strncpy(dest, data, strlen(dest));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
20822,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(STATIC_CONST_TRUE)
{
wprintf(L""%s\n"", data);
}
}
",1
4313,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",0
21574,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_TRUE)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
563,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
switch(6)
{
case 6:
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char dest[50] = """";
strcpy(dest, data);
printLine(data);
}
}
",0
12413,"void function()
{
int64_t * data;
int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
int64_t source[100] = {0}; 
memcpy(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",1
2164,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(1)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
SNPRINTF(dest, strlen(data), ""%s"", data);
printLine(data);
}
}
",0
11895,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(globalFive==5)
{
wprintf(data);
}
}
",1
15502,"void function()
{
int data;
data = -1;
if(globalFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
19200,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
printf(""%s\n"", data);
}
}
",1
20403,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncat(data, source, 100);
printLine(data);
}
}
",1
11969,"void function()
{
int h;
int data;
data = -1;
for(h = 0; h < 1; h++)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
14821,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
while(1)
{
data = dataBuffer;
break;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memcpy(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
11936,"void function()
{
wchar_t * data;
data = NULL;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
",1
6869,"void function()
{
int64_t * data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
if(GLOBAL_CONST_FIVE==5)
{
data = dataBadBuffer;
}
{
int64_t source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printLongLongLine(data[0]);
}
}
}
",0
11829,"void function()
{
int data;
int *dataPtr1 = &data;
int *dataPtr2 = &data;
data = -1;
{
int data = *dataPtr1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
*dataPtr1 = data;
}
{
int data = *dataPtr2;
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
free(buffer);
}
}
}
",1
17553,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
while(1)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
break;
}
{
wchar_t dest[50] = L"""";
memmove(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
16776,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
while(1)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
break;
}
{
char dest[50] = """";
strcpy(dest, data);
printLine(data);
free(data);
}
}
",1
13708,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
wcscpy(data, L""fixedstringtest"");
goodG2BVaSink(data, data);
}
",1
5633,"void function()
{
int data;
data = -1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
int i;
int buffer[10] = { 0 };
if (data < 10)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
}
}
",0
7248,"void function()
{
int64_t * data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
while(1)
{
data = dataBadBuffer;
break;
}
{
int64_t source[100] = {0}; 
memmove(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",0
10750,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",1
21532,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(STATIC_CONST_FIVE==5)
{
goodB2G2VaSinkG(data, data);
}
}
",1
15596,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
switch(6)
{
case 6:
data = dataGoodBuffer;
data[0] = '\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",1
7412,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(globalTrue)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
}
}
",0
592,"void function()
{
wchar_t * data;
CWE121_Stack_Based_Buffer_Overflow__src_wchar_t_declare_cat_34_unionType myUnion;
wchar_t dataBuffer[100];
data = dataBuffer;
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t dest[50] = L"""";
wcscat(dest, data);
printWLine(data);
}
}
}
",0
13809,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(staticTrue)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcpy(dest, data);
printLine(data);
}
}
",1
20185,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wprintf(L""%s\n"", data);
}
}
",1
676,"void function()
{
wchar_t * data;
data = NULL;
if(globalTrue)
{
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
",0
19189,"void function()
{
char * data;
data = NULL;
goto source;
source:
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
free(data);
}
}
",1
19818,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
while(1)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
break;
}
{
wchar_t dest[50] = L"""";
wcsncpy(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
4166,"void function()
{
char * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memmove(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
free(data);
}
}
",0
7407,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
{
size_t i;
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
3110,"void function()
{
int data;
data = -1;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
20059,"void function()
{
short data;
data = 0;
switch(6)
{
case 6:
data = 100-1;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
5221,"void function()
{
int data;
data = -1;
if(5==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
10733,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
while(1)
{
strcpy(data, ""fixedstringtest"");
break;
}
while(1)
{
goodG2BVaSinkB(data, data);
break;
}
}
",1
15491,"void function()
{
char * data;
data = NULL;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
size_t i;
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",1
14990,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
goto source;
source:
data = dataGoodBuffer;
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
19014,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(globalReturnsTrue())
{
goodG2B1VaSinkB(data, data);
}
}
",1
6209,"void function()
{
wchar_t * data;
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_loop_34_unionType myUnion;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t dest[50] = L"""";
size_t i, dataLen;
dataLen = wcslen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = L'\0'; 
printWLine(data);
}
}
}
",0
5982,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
{
char * data = *dataPtr1;
data = dataBuffer - 8;
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
}
",0
14525,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FIVE==5)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
5810,"void function()
{
int data;
data = -1;
while(1)
{
data = RAND32();
break;
}
while(1)
{
{
int i;
int buffer[10] = { 0 };
if (data < 10)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
}
break;
}
}
",0
20688,"void function()
{
int64_t * data;
data = NULL;
if(1)
{
data = (int64_t *)malloc(100*sizeof(int64_t));
if (data == NULL) {exit(-1);}
}
{
int64_t source[100] = {0}; 
memcpy(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
free(data);
}
}
",1
14166,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(staticReturnsTrue())
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
16847,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
while(1)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
break;
}
{
wchar_t dest[50] = L"""";
wcscat(dest, data);
printWLine(data);
}
}
",1
10297,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(5==5)
{
strcpy(data, ""fixedstringtest"");
}
if(5==5)
{
goodG2B2VaSinkB(data, data);
}
}
",1
20529,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
size_t i;
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",1
4964,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
switch(6)
{
case 6:
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char dest[50] = """";
SNPRINTF(dest, strlen(data), ""%s"", data);
printLine(data);
free(data);
}
}
",0
3103,"void function()
{
short data;
data = 0;
if(globalFive==5)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = (short)atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
3097,"void function()
{
int data;
data = -1;
if(globalFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
7950,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(STATIC_CONST_TRUE)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncat(data, source, 100);
printLine(data);
}
}
",0
1669,"void function()
{
twoIntsStruct * data;
twoIntsStruct dataBadBuffer[50];
twoIntsStruct dataGoodBuffer[100];
if(STATIC_CONST_FIVE==5)
{
data = dataBadBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printStructLine(&data[0]);
}
}
}
",0
20142,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcpy(dest, data);
printLine(data);
}
}
",1
11626,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(globalTrue)
{
goodB2G2VaSinkG(data, data);
}
}
",1
14089,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
goto source;
source:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
goto sink;
sink:
goodB2GVaSinkG(data, data);
}
",1
19492,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
}
}
",1
2338,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(staticFive==5)
{
data = dataBuffer - 8;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",0
7896,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
}
",0
1324,"void function()
{
wchar_t * data;
data = NULL;
if(1)
{
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",0
12871,"void function()
{
char * data;
CWE134_Uncontrolled_Format_String__char_connect_socket_printf_34_unionType myUnion;
char dataBuffer[100] = """";
data = dataBuffer;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
printf(""%s\n"", data);
}
}
",1
10274,"void function()
{
if(globalTrue)
{
{
char src[150], dest[100];
int i;
memset(src, 'A', 149);
src[149] = '\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
dest[99] = '\0'; 
printLine(dest);
}
}
}
",1
1591,"void function()
{
wchar_t * data;
data = NULL;
while(1)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
break;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",0
13834,"void function()
{
int h,j;
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
for(h = 0; h < 1; h++)
{
strcpy(data, ""fixedstringtest"");
}
for(j = 0; j < 1; j++)
{
goodG2BVaSinkB(data, data);
}
}
",1
16765,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(globalFive==5)
{
fwprintf(stdout, data);
}
}
",1
10464,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(5==5)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
12430,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100] = """";
data = dataBuffer;
{
char * data = *dataPtr1;
strcpy(data, ""fixedstringtest"");
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
fprintf(stdout, data);
}
}
",1
21916,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strncpy(data, source, strlen(source) + 1);
printLine(data);
}
}
",1
3381,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
badVaSinkB(data, data);
}
}
",0
13609,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(1)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
SNPRINTF(data, 100, ""%s"", source);
printLine(data);
}
}
",1
18141,"void function()
{
wchar_t * data;
data = NULL;
while(1)
{
data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
break;
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
free(data);
}
}
",1
6751,"void function()
{
char * data;
data = NULL;
if(globalTrue)
{
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memcpy(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
free(data);
}
}
",0
14833,"void function()
{
int h;
short data;
data = 0;
for(h = 0; h < 1; h++)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
5723,"void function()
{
int64_t * data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
data = dataBadBuffer;
{
int64_t source[100] = {0}; 
memcpy(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",0
17836,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(STATIC_CONST_FIVE==5)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
}
}
",1
5466,"void function()
{
void * data;
data = NULL;
if(globalFive==5)
{
data = (void *)WIDE_STRING;
}
if(globalFive==5)
{
{
size_t dataLen = strlen((char *)data);
void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
(void)wcscpy(dest, data);
printLine((char *)dest);
}
}
}
",0
13880,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE==5)
{
data = RAND32();
}
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
693,"void function()
{
wchar_t * data;
data = NULL;
if(5==5)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0';
printWLine(data);
}
}
",0
10492,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(5==5)
{
goodG2B1VaSinkB(data, data);
}
}
",1
8237,"void function()
{
int data;
data = -1;
if(1)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(1)
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
}
}
}
",0
3043,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
data = dataBadBuffer;
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
}
",0
13322,"void function()
{
short data;
data = 0;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
17485,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
11576,"void function()
{
int data;
data = -1;
data = 100-1;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
2240,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsTrue())
{
badVaSinkB(data, data);
}
}
",0
20016,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(globalTrue)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",1
8500,"void function()
{
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
charVoid structCharVoid;
structCharVoid.voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid.voidSecond);
memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid.charFirst);
printLine((char *)structCharVoid.voidSecond);
}
}
}
",1
21999,"void function()
{
void * data;
data = NULL;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
{
char * dataGoodBuffer = (char *)malloc(50*sizeof(char));
if (dataGoodBuffer == NULL) {exit(-1);}
memset(dataGoodBuffer, 'A', 50-1);
dataGoodBuffer[50-1] = '\0';
data = (void *)dataGoodBuffer;
}
}
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
if (dest == NULL) {exit(-1);}
(void)strcpy(dest, data);
printLine((char *)dest);
free(dest);
}
}
}
",1
7884,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(staticFive==5)
{
badVaSinkB(data, data);
}
}
",0
11018,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
}
}
",1
8302,"void function()
{
int * data;
data = NULL;
goto source;
source:
data = (int *)malloc(100*sizeof(int));
if (data == NULL) {exit(-1);}
{
int source[100] = {0}; 
memmove(data, source, 100*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",1
2557,"void function()
{
twoIntsStruct * data;
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_34_unionType myUnion;
data = NULL;
data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
myUnion.unionFirst = data;
{
twoIntsStruct * data = myUnion.unionSecond;
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memcpy(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
free(data);
}
}
}
",0
13281,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
goto source;
source:
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
goto sink;
sink:
fwprintf(stdout, L""%s\n"", data);
}
",1
18820,"void function()
{
int * data;
int dataBadBuffer[50];
int dataGoodBuffer[100];
if(globalReturnsTrue())
{
data = dataGoodBuffer;
}
{
int source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
}
}
}
",1
12657,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(globalReturnsTrue())
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncpy(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
19080,"void function()
{
wchar_t * data;
CWE126_Buffer_Overread__wchar_t_alloca_memmove_34_unionType myUnion;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
data = dataGoodBuffer;
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memmove(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
}
",1
9366,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(STATIC_CONST_FIVE==5)
{
goodB2G2VaSinkG(data, data);
}
}
",1
2337,"void function()
{
int * data;
int dataBadBuffer[50];
int dataGoodBuffer[100];
if(staticFive==5)
{
data = dataBadBuffer;
}
{
int source[100] = {0}; 
memcpy(data, source, 100*sizeof(int));
printIntLine(data[0]);
}
}
",0
9423,"void function()
{
twoIntsStruct * data;
data = NULL;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memcpy(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
free(data);
}
}
",1
1993,"void function()
{
char * data;
data = NULL;
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",0
17636,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
while(1)
{
data = dataGoodBuffer;
data[0] = '\0'; 
break;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
SNPRINTF(data, 100, ""%s"", source);
printLine(data);
}
}
",1
3456,"void function()
{
int * data;
data = NULL;
if(globalTrue)
{
data = (int *)malloc(50*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[100] = {0}; 
memcpy(data, source, 100*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",0
6038,"void function()
{
twoIntsStruct * data;
twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
if(STATIC_CONST_TRUE)
{
data = dataBadBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memcpy(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",0
3431,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
{
char * dataCopy = data;
char * data = dataCopy;
badVaSink(data, data);
}
}
",0
8508,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive==5)
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
6966,"void function()
{
short data;
data = 0;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
17404,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticTrue)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
17180,"void function()
{
int data;
data = -1;
while(1)
{
data = 100-1;
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
18976,"void function()
{
char * data;
CWE134_Uncontrolled_Format_String__char_file_vprintf_34_unionType myUnion;
char dataBuffer[100] = """";
data = dataBuffer;
strcpy(data, ""fixedstringtest"");
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
goodG2BVaSink(data, data);
}
}
",1
15676,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
{
char * dataCopy = data;
char * data = dataCopy;
fprintf(stdout, ""%s\n"", data);
}
}
",1
2776,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(staticFive==5)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",0
9278,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
19610,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
10102,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t dest[50] = L"""";
wcsncat(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
}
",1
13829,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
{
char dest[50] = """";
memcpy(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
22950,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
free(data);
}
}
",1
14360,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(globalTrue)
{
goodB2G2VaSinkG(data, data);
}
}
",1
13765,"void function()
{
if(5==5)
{
{
wchar_t src[150], dest[100];
int i;
wmemset(src, L'A', 149);
src[149] = L'\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
dest[99] = L'\0'; 
printWLine(dest);
}
}
}
",1
17168,"void function()
{
wchar_t * data;
CWE134_Uncontrolled_Format_String__wchar_t_console_vfprintf_34_unionType myUnion;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
goodB2GVaSink(data, data);
}
}
",1
10321,"void function()
{
char * data;
data = NULL;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
free(data);
}
}
",1
10442,"void function()
{
short data;
data = 0;
if(staticFive==5)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
8118,"void function()
{
twoIntsStruct * data;
twoIntsStruct dataBadBuffer[50];
twoIntsStruct dataGoodBuffer[100];
if(STATIC_CONST_TRUE)
{
data = dataBadBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",0
9877,"void function()
{
int data;
data = -1;
data = 100-1;
{
int dataCopy = data;
int data = dataCopy;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",1
13675,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(8)
{
case 7:
printLine(""Benign, fixed string"");
break;
default:
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
break;
}
}
",1
7796,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
size_t i, dataLen;
dataLen = wcslen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",0
14793,"void function()
{
int i,k;
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
for(i = 0; i < 1; i++)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
for(k = 0; k < 1; k++)
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
20207,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalFive==5)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
3926,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
17032,"void function()
{
if(5==5)
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid->voidSecond);
memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid->charFirst);
printLine((char *)structCharVoid->voidSecond);
}
}
}
",1
13392,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(GLOBAL_CONST_FIVE==5)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
",1
4934,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(GLOBAL_CONST_TRUE)
{
data = dataBuffer - 8;
}
{
size_t i;
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
11003,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
19475,"void function()
{
wchar_t * data;
data = NULL;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
6847,"void function()
{
int data;
data = -1;
data = RAND32();
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
",0
16597,"void function()
{
char * data;
data = NULL;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
}
}
",1
7504,"void function()
{
char * data;
CWE121_Stack_Based_Buffer_Overflow__dest_char_alloca_cat_34_unionType myUnion;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBadBuffer;
data[0] = '\0'; 
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcat(data, source);
printLine(data);
}
}
}
",0
18791,"void function()
{
wchar_t * data;
data = NULL;
if(1)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memcpy(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
13737,"void function()
{
short data;
data = 0;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
10680,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
7394,"void function()
{
twoIntsStruct * data;
twoIntsStruct dataBadBuffer[50];
twoIntsStruct dataGoodBuffer[100];
if(GLOBAL_CONST_TRUE)
{
data = dataBadBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memcpy(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",0
14629,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticReturnsTrue())
{
data = dataBuffer;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",1
3631,"void function()
{
int64_t * data;
int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
data = dataBadBuffer;
{
int64_t * dataCopy = data;
int64_t * data = dataCopy;
{
int64_t source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printLongLongLine(data[0]);
}
}
}
}
",0
21756,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",1
16071,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(STATIC_CONST_FIVE==5)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
}
}
",1
17987,"void function()
{
int i,k;
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
for(i = 0; i < 1; i++)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
for(k = 0; k < 1; k++)
{
wprintf(L""%s\n"", data);
}
}
",1
14712,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
21489,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
switch(6)
{
case 6:
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
15425,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsTrue())
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
2731,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
while(1)
{
data = dataBuffer - 8;
break;
}
{
wchar_t dest[100*2];
wmemset(dest, L'C', 100*2-1); 
dest[100*2-1] = L'\0'; 
wcscpy(dest, data);
printWLine(dest);
}
}
",0
23226,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
20528,"void function()
{
twoIntsStruct * data;
data = NULL;
if(STATIC_CONST_FIVE==5)
{
data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printStructLine(&data[0]);
free(data);
}
}
}
",1
9916,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
switch(6)
{
case 6:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
12188,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
14418,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
5507,"void function()
{
char * data;
data = NULL;
if(5==5)
{
data = (char *)malloc(10*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
strncpy(data, source, strlen(source) + 1);
printLine(data);
free(data);
}
}
",0
17913,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
14005,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",1
21160,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncat(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
10818,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
15690,"void function()
{
wchar_t * data;
data = NULL;
if(globalReturnsTrue())
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncat(data, source, 100);
printWLine(data);
free(data);
}
}
",1
21831,"void function()
{
twoIntsStruct * data;
twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printStructLine(&data[0]);
}
}
}
",1
8703,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(staticFive==5)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
457,"void function()
{
int data;
data = -1;
data = -1;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
8721,"void function()
{
short data;
data = 0;
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
data = 100-1;
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
6457,"void function()
{
wchar_t * data;
data = NULL;
if(5==5)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
}
{
size_t i;
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
3105,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
badVaSink(data, data);
}
}
",0
9817,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(1)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(1)
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
22222,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncat(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
3930,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsTrue())
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(staticReturnsTrue())
{
badVaSinkB(data, data);
}
}
",0
12713,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_TRUE)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
8677,"void function()
{
twoIntsStruct * data;
twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
if(globalFive==5)
{
data = dataGoodBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printStructLine(&data[0]);
}
}
}
",1
7931,"void function()
{
wchar_t * data;
data = NULL;
goto source;
source:
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
",0
2386,"void function()
{
short data;
data = 0;
if(globalFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
16992,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalTrue)
{
wprintf(L""%s\n"", data);
}
}
",1
7701,"void function()
{
int data;
data = -1;
goto source;
source:
data = RAND32();
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
",0
1001,"void function()
{
int j;
for(j = 0; j < 1; j++)
{
{
charVoid structCharVoid;
structCharVoid.voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid.voidSecond);
memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid.charFirst);
printLine((char *)structCharVoid.voidSecond);
}
}
}
",0
551,"void function()
{
short data;
data = 0;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
15431,"void function()
{
int * data;
data = NULL;
goto source;
source:
data = (int *)malloc(10*sizeof(int));
if (data == NULL) {exit(-1);}
{
int source[10] = {0};
memmove(data, source, 10*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",1
11492,"void function()
{
if(staticFive==5)
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid->voidSecond);
memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid->charFirst);
printLine((char *)structCharVoid->voidSecond);
}
}
}
",1
16644,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive==5)
{
goodB2G2VaSinkG(data, data);
}
}
",1
10069,"void function()
{
void * data;
data = NULL;
if(staticFive==5)
{
{
wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
if (dataBadBuffer == NULL) {exit(-1);}
wmemset(dataBadBuffer, L'A', 50-1);
dataBadBuffer[50-1] = L'\0';
data = (void *)dataBadBuffer;
}
}
if(staticFive==5)
{
{
size_t dataLen = wcslen((wchar_t *)data);
void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
if (dest == NULL) {exit(-1);}
(void)wcscpy(dest, data);
printWLine((wchar_t *)dest);
free(dest);
}
}
}
",1
18447,"void function()
{
int data;
data = -1;
if(globalFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
16581,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(GLOBAL_CONST_FIVE==5)
{
goodG2B1VaSinkB(data, data);
}
}
",1
19649,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
while(1)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
break;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
22599,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
data = NULL;
{
wchar_t * data = *dataPtr1;
data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
free(data);
}
}
}
",1
2865,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(globalFive==5)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
",0
17767,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
}
}
",1
19393,"void function()
{
int data;
data = -1;
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
18435,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(STATIC_CONST_FIVE==5)
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
10114,"void function()
{
int i,k;
int data;
data = -1;
for(i = 0; i < 1; i++)
{
fscanf(stdin, ""%d"", &data);
}
for(k = 0; k < 1; k++)
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
15118,"void function()
{
char * data;
data = NULL;
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
SNPRINTF(data, 100, ""%s"", source);
printLine(data);
free(data);
}
}
",1
10056,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
size_t i, dataLen;
dataLen = wcslen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
17597,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",1
14036,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(staticFive==5)
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
15957,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalFive==5)
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memmove(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
2507,"void function()
{
switch(6)
{
case 6:
{
wchar_t src[150], dest[100];
int i;
wmemset(src, L'A', 149);
src[149] = L'\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
printWLine(dest);
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",0
12816,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsTrue())
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticReturnsTrue())
{
goodB2G2VaSinkG(data, data);
}
}
",1
2046,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(1)
{
data = dataBuffer - 8;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memmove(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
10445,"void function()
{
wchar_t * data;
data = NULL;
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memcpy(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
14911,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
wcscpy(data, L""fixedstringtest"");
}
if(STATIC_CONST_TRUE)
{
fwprintf(stdout, data);
}
}
",1
22822,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memmove(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
15640,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsTrue())
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticReturnsTrue())
{
printf(""%s\n"", data);
}
}
",1
20825,"void function()
{
wchar_t * data;
data = NULL;
if(staticReturnsTrue())
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
SNPRINTF(data, 100, L""%s"", source);
printWLine(data);
free(data);
}
}
",1
4382,"void function()
{
int data;
data = -1;
fscanf(stdin, ""%d"", &data);
{
int dataCopy = data;
int data = dataCopy;
{
int buffer[10] = { 0 };
if (data < 10)
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is too big."");
}
}
}
}
",0
18961,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
17247,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(globalTrue)
{
goodB2G2VaSinkG(data, data);
}
}
",1
977,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t dest[50] = L"""";
SNPRINTF(dest, wcslen(data), L""%s"", data);
printWLine(data);
free(data);
}
}
}
",0
17998,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(globalReturnsTrue())
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscat(dest, data);
printWLine(data);
}
}
",1
2234,"void function()
{
int i;
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
for(i = 0; i < 1; i++)
{
data = dataBadBuffer;
}
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
17657,"void function()
{
short data;
data = 0;
switch(6)
{
case 6:
data = 100-1;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
17743,"void function()
{
char * data;
data = NULL;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
15131,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
data = dataGoodBuffer;
data[0] = L'\0'; 
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = wcslen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printWLine(data);
}
}
}
",1
8796,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(globalReturnsTrue())
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
free(data);
}
}
",1
802,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFive==5)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(globalFive==5)
{
badVaSinkB(data, data);
}
}
",0
10773,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
while(1)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
break;
}
while(1)
{
fwprintf(stdout, L""%s\n"", data);
break;
}
}
",1
6850,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(STATIC_CONST_TRUE)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",0
10517,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
char dest[100*2];
memset(dest, 'C', 100*2-1); 
dest[100*2-1] = '\0'; 
strcpy(dest, data);
printLine(dest);
}
}
",1
23059,"void function()
{
char * data;
data = NULL;
if(GLOBAL_CONST_FIVE==5)
{
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
free(data);
}
}
",1
21926,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(staticFive==5)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",1
19499,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
while(1)
{
data = dataGoodBuffer;
break;
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",1
6282,"void function()
{
int data;
data = -1;
if(globalReturnsTrue())
{
fscanf(stdin, ""%d"", &data);
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
15482,"void function()
{
int data;
data = -1;
if(5==5)
{
fscanf(stdin, ""%d"", &data);
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
20487,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(staticReturnsTrue())
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
}
}
",1
15614,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(staticReturnsTrue())
{
goodG2B1VaSinkB(data, data);
}
}
",1
15023,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
printf(""%s\n"", data);
}
}
",1
21324,"void function()
{
int * data;
data = NULL;
if(5==5)
{
data = (int *)ALLOCA(10*sizeof(int));
}
{
int source[10] = {0};
memmove(data, source, 10*sizeof(int));
printIntLine(data[0]);
}
}
",1
12882,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_TRUE)
{
data = RAND32();
}
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
20180,"void function()
{
int64_t * data;
int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
int64_t source[100] = {0}; 
memcpy(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",1
11229,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
{
wchar_t * data = *dataPtr1;
data = dataGoodBuffer;
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memmove(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
}
",1
6631,"void function()
{
int data;
data = -1;
if(staticFive==5)
{
fscanf(stdin, ""%d"", &data);
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
15339,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
13187,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticReturnsTrue())
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
20727,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(globalFive==5)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
",1
21228,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
15793,"void function()
{
int h,j;
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
for(h = 0; h < 1; h++)
{
strcpy(data, ""fixedstringtest"");
}
for(j = 0; j < 1; j++)
{
printf(data);
}
}
",1
22189,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
while(1)
{
data = dataBuffer;
break;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
15978,"void function()
{
int h;
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
for(h = 0; h < 1; h++)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
",1
16278,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
wcscpy(data, L""fixedstringtest"");
}
if(staticReturnsTrue())
{
fwprintf(stdout, data);
}
}
",1
19895,"void function()
{
int data;
data = -1;
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
",1
14733,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
9174,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
16689,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
4480,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
data = dataBadBuffer;
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",0
21333,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
goodB2G2VaSinkG(data, data);
}
}
",1
22802,"void function()
{
int64_t * data;
int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
int64_t source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printLongLongLine(data[0]);
}
}
}
",1
18264,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memmove(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
19473,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticFive==5)
{
data = dataBuffer;
}
{
size_t i;
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",1
4912,"void function()
{
int j;
for(j = 0; j < 1; j++)
{
{
charVoid structCharVoid;
structCharVoid.voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid.voidSecond);
memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid.charFirst);
printWLine((wchar_t *)structCharVoid.voidSecond);
}
}
}
",0
21997,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
1582,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalFive==5)
{
badVaSinkB(data, data);
}
}
",0
17308,"void function()
{
int i,k;
int data;
data = -1;
for(i = 0; i < 1; i++)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
for(k = 0; k < 1; k++)
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
free(buffer);
}
}
}
",1
4822,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
{
char dest[50] = """";
SNPRINTF(dest, strlen(data), ""%s"", data);
printLine(data);
}
}
",0
6143,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(staticTrue)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
",0
3278,"void function()
{
int data;
CWE195_Signed_to_Unsigned_Conversion_Error__rand_malloc_34_unionType myUnion;
data = -1;
data = RAND32();
myUnion.unionFirst = data;
{
int data = myUnion.unionSecond;
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
}
",0
15121,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
14442,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
1773,"void function()
{
int data;
data = -1;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
",0
9448,"void function()
{
int data;
data = -1;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
18245,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(5==5)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",1
5018,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(staticReturnsTrue())
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
memcpy(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",0
6811,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(globalFive==5)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",0
16361,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(globalTrue)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
}
}
",1
4530,"void function()
{
wchar_t * data;
data = NULL;
while(1)
{
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
break;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscat(data, source);
printWLine(data);
free(data);
}
}
",0
15224,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
4553,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(globalTrue)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memmove(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",0
5464,"void function()
{
char * data;
data = NULL;
switch(6)
{
case 6:
data = (char *)malloc(10*sizeof(char));
if (data == NULL) {exit(-1);}
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[10+1] = SRC_STRING;
strncpy(data, source, strlen(source) + 1);
printLine(data);
free(data);
}
}
",0
13606,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(globalFive==5)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
}
}
",1
1891,"void function()
{
int * data;
int dataBadBuffer[50];
int dataGoodBuffer[100];
if(5==5)
{
data = dataBadBuffer;
}
{
int source[100] = {0}; 
memcpy(data, source, 100*sizeof(int));
printIntLine(data[0]);
}
}
",0
20208,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memmove(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
21260,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(staticReturnsTrue())
{
fwprintf(stdout, data);
}
}
",1
13031,"void function()
{
int data;
data = -1;
if(globalTrue)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
23218,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalFive==5)
{
strcpy(data, ""fixedstringtest"");
}
if(globalFive==5)
{
goodG2B2VaSinkB(data, data);
}
}
",1
13668,"void function()
{
void * data;
data = NULL;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = (void *)CHAR_STRING;
}
if(STATIC_CONST_TRUE)
{
{
size_t dataLen = strlen((char *)data);
void * dest = (void *)ALLOCA((dataLen+1) * 1);
(void)strcpy(dest, data);
printLine((char *)dest);
}
}
}
",1
16699,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(staticFive==5)
{
goodG2B1VaSinkB(data, data);
}
}
",1
3773,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
{
wchar_t * data = *dataPtr1;
data = dataBuffer - 8;
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
}
",0
21915,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
data = dataGoodBuffer;
break;
}
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
11785,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
while(1)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
break;
}
{
char dest[50] = """";
strcpy(dest, data);
printLine(data);
}
}
",1
21563,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5==5)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(5==5)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
272,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(globalFive==5)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",0
22379,"void function()
{
int * data;
int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
while(1)
{
data = dataGoodBuffer;
break;
}
{
int source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
}
}
}
",1
19638,"void function()
{
if(GLOBAL_CONST_FIVE==5)
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid->voidSecond);
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid->charFirst);
printWLine((wchar_t *)structCharVoid->voidSecond);
free(structCharVoid);
}
}
}
",1
9876,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
22962,"void function()
{
short data;
data = 0;
if(staticReturnsTrue())
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
5727,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
while(1)
{
data = dataBadBuffer;
data[0] = L'\0'; 
break;
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
}
}
",0
13202,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
13999,"void function()
{
wchar_t * data;
data = NULL;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
}
{
wchar_t source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = wcslen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printWLine(data);
free(data);
}
}
",1
2897,"void function()
{
char * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memmove(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
21172,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
",1
14141,"void function()
{
wchar_t * data;
data = NULL;
if(staticFive==5)
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscat(data, source);
printWLine(data);
free(data);
}
}
",1
1627,"void function()
{
int data;
data = -1;
data = RAND32();
{
int dataCopy = data;
int data = dataCopy;
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
}
",0
5857,"void function()
{
short data;
data = 0;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
19453,"void function()
{
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid->voidSecond);
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid->charFirst);
printWLine((wchar_t *)structCharVoid->voidSecond);
free(structCharVoid);
}
}
}
",1
21595,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
6990,"void function()
{
wchar_t * data;
data = NULL;
data = (wchar_t *)malloc(10*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
{
wchar_t source[10+1] = SRC_STRING;
memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
free(data);
}
}
",0
7626,"void function()
{
int data;
int *dataPtr1 = &data;
int *dataPtr2 = &data;
data = -1;
{
int data = *dataPtr1;
fscanf(stdin, ""%d"", &data);
*dataPtr1 = data;
}
{
int data = *dataPtr2;
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
}
",0
21633,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100] = """";
data = dataBuffer;
{
char * data = *dataPtr1;
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
944,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE==5)
{
fscanf(stdin, ""%d"", &data);
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
19380,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
memcpy(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
10516,"void function()
{
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
{
char data[150], dest[100];
memset(data, 'A', 149);
data[149] = '\0';
memcpy(dest, data, 99*sizeof(char));
dest[99] = '\0'; 
printLine(dest);
}
}
}
",1
15542,"void function()
{
wchar_t * data;
data = NULL;
if(1)
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
19669,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
{
char dest[50] = """";
memmove(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
13640,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
data = dataGoodBuffer;
data[0] = '\0'; 
{
char * dataCopy = data;
char * data = dataCopy;
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
}
",1
9990,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
21927,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strncpy(data, source, strlen(source) + 1);
printLine(data);
}
}
",1
6784,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
while(1)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
break;
}
{
wchar_t dest[50] = L"""";
wcsncpy(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",0
16615,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
18226,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
20052,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
7428,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
badVaSinkB(data, data);
}
}
",0
18369,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(GLOBAL_CONST_TRUE)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncpy(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
21964,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
switch(6)
{
case 6:
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(8)
{
case 7:
printLine(""Benign, fixed string"");
break;
default:
goodB2G1VaSinkG(data, data);
break;
}
}
",1
11643,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wprintf(L""%s\n"", data);
}
}
",1
10224,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
}
}
",1
8417,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
size_t i, dataLen;
dataLen = strlen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
16085,"void function()
{
int data;
data = -1;
goto source;
source:
data = 100-1;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
22537,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
546,"void function()
{
int data;
data = -1;
if(staticFive==5)
{
data = RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
21794,"void function()
{
wchar_t * data;
data = NULL;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
SNPRINTF(data, 100, L""%s"", source);
printWLine(data);
free(data);
}
}
",1
2815,"void function()
{
goto sink;
sink:
{
charVoid structCharVoid;
structCharVoid.voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid.voidSecond);
memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid.charFirst);
printWLine((wchar_t *)structCharVoid.voidSecond);
}
}
",0
13949,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
821,"void function()
{
int data;
int *dataPtr1 = &data;
int *dataPtr2 = &data;
data = -1;
{
int data = *dataPtr1;
data = -1;
*dataPtr1 = data;
}
{
int data = *dataPtr2;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",0
4044,"void function()
{
void * data;
data = NULL;
if(globalReturnsTrue())
{
data = (void *)WIDE_STRING;
}
if(globalReturnsTrue())
{
{
size_t dataLen = strlen((char *)data);
void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
(void)wcscpy(dest, data);
printLine((char *)dest);
}
}
}
",0
23180,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",1
696,"void function()
{
wchar_t * data;
CWE121_Stack_Based_Buffer_Overflow__CWE806_wchar_t_alloca_ncat_34_unionType myUnion;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t dest[50] = L"""";
wcsncat(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
}
",0
9665,"void function()
{
int h;
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
for(h = 0; h < 1; h++)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
memmove(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
23077,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFive==5)
{
wcscpy(data, L""fixedstringtest"");
}
if(globalFive==5)
{
goodG2B2VaSinkB(data, data);
}
}
",1
400,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
{
char * dataCopy = data;
char * data = dataCopy;
fprintf(stdout, data);
}
}
",0
1268,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalReturnsTrue())
{
data = dataBuffer - 8;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0';
printWLine(data);
}
}
",0
20478,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
strcpy(data, ""fixedstringtest"");
}
if(globalReturnsTrue())
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",1
19270,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
goto source;
source:
data = dataGoodBuffer;
data[0] = L'\0'; 
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
5689,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(staticFive==5)
{
wprintf(data);
}
}
",0
22510,"void function()
{
int data;
CWE122_Heap_Based_Buffer_Overflow__c_CWE129_rand_34_unionType myUnion;
data = -1;
data = RAND32();
myUnion.unionFirst = data;
{
int data = myUnion.unionSecond;
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
free(buffer);
}
}
}
",1
6550,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
19719,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
break;
}
{
wchar_t dest[50] = L"""";
SNPRINTF(dest, wcslen(data), L""%s"", data);
printWLine(data);
free(data);
}
}
",1
11679,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(globalTrue)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncat(data, source, 100);
printWLine(data);
}
}
",1
21520,"void function()
{
wchar_t * data;
data = NULL;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
1082,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(STATIC_CONST_TRUE)
{
badVaSinkB(data, data);
}
}
",0
9716,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(globalTrue)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
6116,"void function()
{
if(1)
{
{
wchar_t src[150], dest[100];
int i;
wmemset(src, L'A', 149);
src[149] = L'\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
printWLine(dest);
}
}
}
",0
11584,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(globalFive==5)
{
goodG2B1VaSinkB(data, data);
}
}
",1
14680,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",1
4983,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
while(1)
{
data = dataBadBuffer;
data[0] = L'\0'; 
break;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
SNPRINTF(data, 100, L""%s"", source);
printWLine(data);
}
}
",0
6815,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
{
char * dataCopy = data;
char * data = dataCopy;
printf(data);
}
}
",0
20275,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(globalTrue)
{
goodB2G2VaSinkG(data, data);
}
}
",1
4473,"void function()
{
char * data;
CWE127_Buffer_Underread__malloc_char_memmove_34_unionType myUnion;
data = NULL;
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memmove(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
}
",0
21417,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsTrue())
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
21807,"void function()
{
int64_t * data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
if(staticFive==5)
{
data = dataGoodBuffer;
}
{
int64_t source[100] = {0}; 
memmove(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",1
11367,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
{
char * data = *dataPtr1;
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char dest[50] = """";
size_t i, dataLen;
dataLen = strlen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = '\0'; 
printLine(data);
}
}
}
",1
5832,"void function()
{
short data;
data = 0;
goto source;
source:
fscanf (stdin, ""%hd"", &data);
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
12394,"void function()
{
int data;
data = -1;
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
15867,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(5==5)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
SNPRINTF(dest, strlen(data), ""%s"", data);
printLine(data);
}
}
",1
21361,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(globalFive==5)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
8178,"void function()
{
short data;
data = 0;
if(5==5)
{
data = (short)RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
13287,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
strcpy(data, ""fixedstringtest"");
}
if(GLOBAL_CONST_FIVE==5)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",1
15002,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
data = dataBuffer;
break;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memmove(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
14816,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
wcscpy(data, L""fixedstringtest"");
}
if(staticFive==5)
{
wprintf(data);
}
}
",1
7867,"void function()
{
short data;
data = 0;
if(5==5)
{
data = (short)RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
3799,"void function()
{
int data;
data = -1;
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
{
int dataCopy = data;
int data = dataCopy;
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
}
",0
7143,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
fscanf(stdin, ""%d"", &data);
}
if(staticReturnsTrue())
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
free(buffer);
}
}
}
",0
16070,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(1)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
20437,"void function()
{
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
{
char data[150], dest[100];
memset(data, 'A', 149);
data[149] = '\0';
memcpy(dest, data, 99*sizeof(char));
dest[99] = '\0'; 
printLine(dest);
}
}
}
",1
20172,"void function()
{
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid->voidSecond);
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid->charFirst);
printLine((char *)structCharVoid->voidSecond);
free(structCharVoid);
}
}
}
",1
8244,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
22492,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
goodB2GVaSink(data, data);
}
",1
10742,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(GLOBAL_CONST_TRUE)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
5922,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalTrue)
{
badVaSinkB(data, data);
}
}
",0
586,"void function()
{
int data;
int *dataPtr1 = &data;
int *dataPtr2 = &data;
data = -1;
{
int data = *dataPtr1;
fscanf(stdin, ""%d"", &data);
*dataPtr1 = data;
}
{
int data = *dataPtr2;
{
int i;
int buffer[10] = { 0 };
if (data >= 0)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
}
}
}
",0
10347,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
11319,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
{
char * dataCopy = data;
char * data = dataCopy;
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
}
",1
7445,"void function()
{
int i,j;
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
for(i = 0; i < 1; i++)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
for(j = 0; j < 1; j++)
{
badVaSinkB(data, data);
}
}
",0
14753,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(staticTrue)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncpy(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
8171,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
{
char * dataCopy = data;
char * data = dataCopy;
{
char dest[50] = """";
size_t i, dataLen;
dataLen = strlen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
}
",0
22538,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(1)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(1)
{
goodB2G2VaSinkG(data, data);
}
}
",1
6694,"void function()
{
wchar_t * data;
data = NULL;
if(1)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",0
3844,"void function()
{
short data;
data = 0;
if(globalFive==5)
{
data = (short)RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
14804,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(1)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
",1
10553,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
14065,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(globalFive==5)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
}
}
",1
4030,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
}
}
",0
15067,"void function()
{
twoIntsStruct * data;
data = NULL;
if(globalReturnsTrue())
{
data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printStructLine(&data[0]);
free(data);
}
}
}
",1
214,"void function()
{
wchar_t * data;
data = NULL;
if(staticTrue)
{
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memmove(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
",0
15620,"void function()
{
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
{
char data[150], dest[100];
memset(data, 'A', 149);
data[149] = '\0';
strncpy(dest, data, 99);
dest[99] = '\0'; 
printLine(dest);
}
}
}
",1
13940,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
19584,"void function()
{
char * data;
data = NULL;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = strlen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printLine(data);
free(data);
}
}
",1
6606,"void function()
{
short data;
data = 0;
if(GLOBAL_CONST_FIVE==5)
{
data = (short)RAND32();
}
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
",0
18128,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
printf(""%s\n"", data);
}
}
",1
15261,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
memmove(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
14450,"void function()
{
int data;
data = -1;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
22828,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataGoodBuffer;
data[0] = L'\0'; 
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
19613,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
}
}
",1
19065,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
switch(6)
{
case 6:
strcpy(data, ""fixedstringtest"");
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
goodG2B2VaSinkB(data, data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
6824,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalTrue)
{
data = dataBuffer - 8;
}
{
size_t i;
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",0
14665,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(GLOBAL_CONST_FIVE==5)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
free(data);
}
}
",1
12014,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t dest[50] = L"""";
SNPRINTF(dest, wcslen(data), L""%s"", data);
printWLine(data);
}
}
}
",1
18182,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
19355,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FIVE==5)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
free(buffer);
}
}
}
",1
20210,"void function()
{
int * data;
data = NULL;
if(globalReturnsTrue())
{
data = (int *)malloc(10*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[10] = {0};
size_t i;
for (i = 0; i < 10; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
free(data);
}
}
",1
10120,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFive==5)
{
wcscpy(data, L""fixedstringtest"");
}
if(globalFive==5)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
}
}
",1
13406,"void function()
{
twoIntsStruct * data;
twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
if(staticReturnsTrue())
{
data = dataGoodBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printStructLine(&data[0]);
}
}
}
",1
2055,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalReturnsTrue())
{
wprintf(data);
}
}
",0
15138,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticTrue)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
19441,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(staticTrue)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
}
}
",1
11293,"void function()
{
int data;
data = -1;
if(5==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
8655,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
strcpy(data, ""fixedstringtest"");
}
if(GLOBAL_CONST_TRUE)
{
goodG2B2VaSinkB(data, data);
}
}
",1
19759,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
23117,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = wcslen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printWLine(data);
}
}
",1
23115,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
15358,"void function()
{
wchar_t * data;
data = NULL;
if(globalReturnsTrue())
{
data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
}
{
wchar_t source[10+1] = SRC_STRING;
memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
free(data);
}
}
",1
13456,"void function()
{
int data;
data = -1;
if(staticTrue)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
2306,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
badVaSinkB(data, data);
}
}
",0
8791,"void function()
{
int data;
data = -1;
if(1)
{
fscanf(stdin, ""%d"", &data);
}
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
free(buffer);
}
}
}
",1
16948,"void function()
{
wchar_t * data;
data = NULL;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscat(data, source);
printWLine(data);
free(data);
}
}
",1
14693,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",1
472,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FIVE==5)
{
fscanf(stdin, ""%d"", &data);
}
if(GLOBAL_CONST_FIVE==5)
{
{
int buffer[10] = { 0 };
if (data >= 0)
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is negative"");
}
}
}
}
",0
5481,"void function()
{
wchar_t * data;
data = NULL;
if(staticTrue)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0';
printWLine(data);
}
}
",0
21510,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
10393,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
",1
12823,"void function()
{
wchar_t * data;
data = NULL;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
}
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
free(data);
}
}
",1
262,"void function()
{
int data;
data = -1;
if(globalFive==5)
{
fscanf(stdin, ""%d"", &data);
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
22447,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
8818,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(5==5)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
",1
6822,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(1)
{
data = dataBuffer - 8;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",0
2908,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(GLOBAL_CONST_TRUE)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",0
7350,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(staticFive==5)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
}
}
",0
13819,"void function()
{
twoIntsStruct * data;
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_struct_memcpy_34_unionType myUnion;
data = NULL;
data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
myUnion.unionFirst = data;
{
twoIntsStruct * data = myUnion.unionSecond;
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memcpy(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
free(data);
}
}
}
",1
18024,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
wprintf(L""%s\n"", data);
}
}
",1
8983,"void function()
{
int data;
data = -1;
if(globalReturnsTrue())
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
10398,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticTrue)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
19308,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_TRUE)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(GLOBAL_CONST_TRUE)
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
6327,"void function()
{
if(STATIC_CONST_FIVE==5)
{
{
char data[150], dest[100];
memset(data, 'A', 149);
data[149] = '\0';
strncpy(dest, data, 99);
printLine(dest);
}
}
}
",0
12323,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(staticFive==5)
{
data = dataGoodBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memmove(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
11141,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
wcscpy(data, L""fixedstringtest"");
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
goodG2BVaSink(data, data);
}
}
",1
19663,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",1
15099,"void function()
{
char * data;
CWE134_Uncontrolled_Format_String__char_connect_socket_vprintf_34_unionType myUnion;
char dataBuffer[100] = """";
data = dataBuffer;
strcpy(data, ""fixedstringtest"");
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
goodG2BVaSink(data, data);
}
}
",1
12500,"void function()
{
short data;
short *dataPtr1 = &data;
short *dataPtr2 = &data;
data = 0;
{
short data = *dataPtr1;
data = 100-1;
*dataPtr1 = data;
}
{
short data = *dataPtr2;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",1
5785,"void function()
{
int i,j;
int data;
data = -1;
for(i = 0; i < 1; i++)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
for(j = 0; j < 1; j++)
{
{
int i;
int buffer[10] = { 0 };
if (data < 10)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
}
}
}
",0
22419,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsTrue())
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
6816,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(staticFive==5)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
",0
5459,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalReturnsTrue())
{
data = dataBuffer - 8;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
19404,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
19556,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5==5)
{
wcscpy(data, L""fixedstringtest"");
}
if(5==5)
{
fwprintf(stdout, data);
}
}
",1
15675,"void function()
{
void * data;
data = NULL;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (void *)CHAR_STRING;
}
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = strlen((char *)data);
void * dest = (void *)ALLOCA((dataLen+1) * 1);
(void)strcpy(dest, data);
printLine((char *)dest);
}
}
}
",1
22971,"void function()
{
int * data;
int dataBadBuffer[50];
int dataGoodBuffer[100];
goto source;
source:
data = dataGoodBuffer;
{
int source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
}
}
}
",1
8162,"void function()
{
int data;
data = -1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
18891,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
wcscpy(data, L""fixedstringtest"");
}
if(staticReturnsTrue())
{
goodG2B2VaSinkB(data, data);
}
}
",1
19615,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
",1
8288,"void function()
{
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t src[150], dest[100];
int i;
wmemset(src, L'A', 149);
src[149] = L'\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
dest[99] = L'\0'; 
printWLine(dest);
}
}
}
",1
4771,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(1)
{
data = dataBuffer - 8;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",0
14321,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
fwprintf(stdout, L""%s\n"", data);
}
",1
7944,"void function()
{
int data;
data = -1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
17526,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(5==5)
{
goodG2B1VaSinkB(data, data);
}
}
",1
8560,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
12102,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
if(staticReturnsTrue())
{
data = dataGoodBuffer;
}
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
22399,"void function()
{
int data;
int *dataPtr1 = &data;
int *dataPtr2 = &data;
data = -1;
{
int data = *dataPtr1;
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
*dataPtr1 = data;
}
{
int data = *dataPtr2;
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
19540,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0'; 
printLine(data);
}
}
",1
11303,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
goto source;
source:
data = dataBuffer;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
19861,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(GLOBAL_CONST_TRUE)
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
19841,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncpy(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
14648,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",1
20489,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(1)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",1
10756,"void function()
{
int h;
wchar_t * data;
data = NULL;
for(h = 0; h < 1; h++)
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
7259,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
while(1)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
break;
}
while(1)
{
badVaSinkB(data, data);
break;
}
}
",0
448,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsTrue())
{
{
int buffer[10] = { 0 };
if (data < 10)
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is too big."");
}
}
}
}
",0
1835,"void function()
{
short data;
data = 0;
goto source;
source:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
4318,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(GLOBAL_CONST_TRUE)
{
data = dataBuffer - 8;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",0
7901,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
if(globalFive==5)
{
data = dataBadBuffer;
}
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
18296,"void function()
{
if(GLOBAL_CONST_TRUE)
{
{
char src[150], dest[100];
int i;
memset(src, 'A', 149);
src[149] = '\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
dest[99] = '\0'; 
printLine(dest);
}
}
}
",1
3880,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
data = dataBadBuffer;
data[0] = L'\0'; 
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t source[10+1] = SRC_STRING;
memmove(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
}
",0
5749,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_TRUE)
{
badVaSinkB(data, data);
}
}
",0
22641,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(globalTrue)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncpy(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
9016,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(globalReturnsTrue())
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
17192,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcpy(dest, data);
printLine(data);
free(data);
}
}
",1
4995,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(1)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
22209,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
goto source;
source:
data = dataGoodBuffer;
data[0] = L'\0'; 
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
14917,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
goto source;
source:
strcpy(data, ""fixedstringtest"");
goto sink;
sink:
goodG2BVaSinkB(data, data);
}
",1
14583,"void function()
{
char * data;
data = NULL;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memcpy(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
free(data);
}
}
",1
16476,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
strcpy(data, ""fixedstringtest"");
}
if(globalReturnsTrue())
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",1
21341,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(5==5)
{
goodG2B1VaSinkB(data, data);
}
}
",1
20188,"void function()
{
int i,k;
void * data;
data = NULL;
for(i = 0; i < 1; i++)
{
data = (void *)WIDE_STRING;
}
for(k = 0; k < 1; k++)
{
{
size_t dataLen = wcslen((wchar_t *)data);
void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
(void)wcscpy(dest, data);
printWLine((wchar_t *)dest);
}
}
}
",1
14403,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticReturnsTrue())
{
data = dataBuffer;
}
{
size_t i;
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",1
3319,"void function()
{
int data;
data = -1;
if(staticTrue)
{
data = RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
19386,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
switch(6)
{
case 6:
data = dataBuffer;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
strncpy(dest, data, strlen(dest));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
7461,"void function()
{
short data;
data = 0;
if(STATIC_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
",0
13043,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticTrue)
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
223,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
switch(6)
{
case 6:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
wprintf(data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",0
212,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",0
12308,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
if(globalReturnsTrue())
{
data = dataGoodBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memmove(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
12930,"void function()
{
wchar_t * data;
data = NULL;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
14256,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
14270,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
wcscpy(data, L""fixedstringtest"");
}
if(GLOBAL_CONST_TRUE)
{
goodG2B2VaSinkB(data, data);
}
}
",1
10223,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
switch(6)
{
case 6:
data = dataGoodBuffer;
data[0] = L'\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
}
}
",1
483,"void function()
{
short data;
CWE194_Unexpected_Sign_Extension__fgets_strncpy_34_unionType myUnion;
data = 0;
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = (short)atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
myUnion.unionFirst = data;
{
short data = myUnion.unionSecond;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",0
13648,"void function()
{
int data;
data = -1;
if(5==5)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
16552,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
8952,"void function()
{
int h,j;
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
for(h = 0; h < 1; h++)
{
wcscpy(data, L""fixedstringtest"");
}
for(j = 0; j < 1; j++)
{
wprintf(data);
}
}
",1
13877,"void function()
{
int i,k;
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
for(i = 0; i < 1; i++)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
for(k = 0; k < 1; k++)
{
goodB2GVaSinkG(data, data);
}
}
",1
15436,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(5==5)
{
fprintf(stdout, data);
}
}
",1
20586,"void function()
{
int i,k;
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
for(i = 0; i < 1; i++)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
for(k = 0; k < 1; k++)
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
13718,"void function()
{
int * data;
data = NULL;
if(globalFive==5)
{
data = (int *)malloc(10*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[10] = {0};
memmove(data, source, 10*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",1
19099,"void function()
{
int data;
data = -1;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
18400,"void function()
{
int * data;
data = NULL;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = (int *)malloc(10*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[10] = {0};
memmove(data, source, 10*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",1
15389,"void function()
{
int * data;
int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
if(staticTrue)
{
data = dataGoodBuffer;
}
{
int source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
}
}
}
",1
15673,"void function()
{
int data;
data = -1;
if(5==5)
{
fscanf(stdin, ""%d"", &data);
}
if(5==5)
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
1259,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
goto source;
source:
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
2861,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
19958,"void function()
{
int64_t * data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
int64_t source[100] = {0}; 
memcpy(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",1
4728,"void function()
{
char * data;
data = NULL;
while(1)
{
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
break;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncat(data, source, 100);
printLine(data);
free(data);
}
}
",0
15815,"void function()
{
char * data;
CWE134_Uncontrolled_Format_String__char_console_w32_vsnprintf_34_unionType myUnion;
char dataBuffer[100] = """";
data = dataBuffer;
strcpy(data, ""fixedstringtest"");
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
goodG2BVaSink(data, data);
}
}
",1
12220,"void function()
{
char * data;
data = NULL;
if(GLOBAL_CONST_FIVE==5)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",1
9862,"void function()
{
char * data;
data = NULL;
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",1
15818,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wprintf(L""%s\n"", data);
}
}
",1
17407,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
data = NULL;
{
char * data = *dataPtr1;
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
size_t i;
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
}
",1
18848,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
18145,"void function()
{
wchar_t * data;
data = NULL;
if(STATIC_CONST_FIVE==5)
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
9414,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(globalReturnsTrue())
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
",1
6544,"void function()
{
int i,j;
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
for(i = 0; i < 1; i++)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
for(j = 0; j < 1; j++)
{
badVaSinkB(data, data);
}
}
",0
20235,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0'; 
printLine(data);
}
}
",1
383,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(GLOBAL_CONST_TRUE)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
SNPRINTF(data, 100, ""%s"", source);
printLine(data);
}
}
",0
19730,"void function()
{
int64_t * data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
int64_t source[100] = {0}; 
memmove(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",1
15819,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(1)
{
data = dataBuffer;
}
{
char dest[100*2];
memset(dest, 'C', 100*2-1); 
dest[100*2-1] = '\0'; 
strcpy(dest, data);
printLine(dest);
}
}
",1
18511,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(1)
{
data = dataBuffer;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
strncpy(dest, data, strlen(dest));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
17298,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(globalFive==5)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscat(dest, data);
printWLine(data);
}
}
",1
9464,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",1
12789,"void function()
{
char * data;
data = NULL;
switch(6)
{
case 6:
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memmove(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
18301,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
size_t i, dataLen;
dataLen = strlen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
15165,"void function()
{
int h;
int * data;
data = NULL;
for(h = 0; h < 1; h++)
{
data = (int *)ALLOCA(10*sizeof(int));
}
{
int source[10] = {0};
memcpy(data, source, 10*sizeof(int));
printIntLine(data[0]);
}
}
",1
3472,"void function()
{
wchar_t * data;
data = NULL;
if(staticReturnsTrue())
{
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",0
1593,"void function()
{
char * data;
data = NULL;
if(globalTrue)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
15528,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(STATIC_CONST_FIVE==5)
{
fwprintf(stdout, data);
}
}
",1
21204,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(staticReturnsTrue())
{
wprintf(L""%s\n"", data);
}
}
",1
8892,"void function()
{
char * data;
data = NULL;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
}
}
",1
16270,"void function()
{
char * data;
data = NULL;
if(staticFive==5)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
strncpy(dest, data, strlen(dest));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
14381,"void function()
{
short data;
data = 0;
if(5==5)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
14931,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
goto source;
source:
data = dataGoodBuffer;
data[0] = '\0'; 
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",1
16277,"void function()
{
wchar_t * data;
CWE134_Uncontrolled_Format_String__wchar_t_environment_fprintf_34_unionType myUnion;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
fwprintf(stdout, L""%s\n"", data);
}
}
",1
18334,"void function()
{
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid->voidSecond);
memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid->charFirst);
printLine((char *)structCharVoid->voidSecond);
}
}
}
",1
8737,"void function()
{
void * data;
data = NULL;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
{
char * dataGoodBuffer = (char *)malloc(50*sizeof(char));
if (dataGoodBuffer == NULL) {exit(-1);}
memset(dataGoodBuffer, 'A', 50-1);
dataGoodBuffer[50-1] = '\0';
data = (void *)dataGoodBuffer;
}
}
if(STATIC_CONST_TRUE)
{
{
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, 1);
if (dest == NULL) {exit(-1);}
(void)strcpy(dest, data);
printLine((char *)dest);
free(dest);
}
}
}
",1
11192,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
break;
}
{
wchar_t dest[50] = L"""";
wcscat(dest, data);
printWLine(data);
}
}
",1
14488,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = strlen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printLine(data);
}
}
",1
21855,"void function()
{
short data;
data = 0;
if(staticFive==5)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
5467,"void function()
{
if(globalReturnsTrue())
{
{
charVoid structCharVoid;
structCharVoid.voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid.voidSecond);
memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid.charFirst);
printWLine((wchar_t *)structCharVoid.voidSecond);
}
}
}
",0
13174,"void function()
{
if(STATIC_CONST_TRUE)
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid->voidSecond);
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid->charFirst);
printWLine((wchar_t *)structCharVoid->voidSecond);
free(structCharVoid);
}
}
}
",1
18153,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5==5)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(5==5)
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
6137,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
switch(6)
{
case 6:
data = dataBadBuffer;
data[0] = L'\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",0
15772,"void function()
{
int data;
data = -1;
if(1)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(1)
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
6972,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(1)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscat(dest, data);
printWLine(data);
}
}
",0
13898,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(staticReturnsTrue())
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
memcpy(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
13271,"void function()
{
short data;
data = 0;
if(STATIC_CONST_TRUE)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
20950,"void function()
{
int * data;
data = NULL;
if(GLOBAL_CONST_TRUE)
{
data = (int *)ALLOCA(10*sizeof(int));
}
{
int source[10] = {0};
memmove(data, source, 10*sizeof(int));
printIntLine(data[0]);
}
}
",1
17663,"void function()
{
twoIntsStruct * data;
twoIntsStruct dataBadBuffer[50];
twoIntsStruct dataGoodBuffer[100];
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memcpy(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",1
14731,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(GLOBAL_CONST_FIVE==5)
{
data = dataBuffer;
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",1
2746,"void function()
{
short data;
data = 0;
while(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
11555,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticFive==5)
{
printf(""%s\n"", data);
}
}
",1
15864,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
size_t i, dataLen;
dataLen = strlen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
17098,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
398,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
switch(6)
{
case 6:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",0
1481,"void function()
{
if(staticReturnsTrue())
{
{
char data[150], dest[100];
memset(data, 'A', 149);
data[149] = '\0';
strncpy(dest, data, 99);
printLine(dest);
}
}
}
",0
6520,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
{
wchar_t * data = *dataPtr1;
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
}
}
}
",0
301,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
goto source;
source:
data = dataBadBuffer;
data[0] = '\0'; 
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
}
}
",0
2068,"void function()
{
int i;
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
for(i = 0; i < 1; i++)
{
data = dataBuffer - 8;
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
",0
2075,"void function()
{
short data;
data = 0;
if(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
22630,"void function()
{
if(staticReturnsTrue())
{
{
wchar_t data[150], dest[100];
wmemset(data, L'A', 149);
data[149] = L'\0';
wcsncpy(dest, data, 99);
dest[99] = L'\0'; 
printWLine(dest);
}
}
}
",1
20903,"void function()
{
int data;
data = -1;
if(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
free(buffer);
}
}
}
",1
8936,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
strcpy(data, ""fixedstringtest"");
}
if(globalReturnsTrue())
{
goodG2B2VaSinkB(data, data);
}
}
",1
19411,"void function()
{
switch(6)
{
case 6:
{
wchar_t src[150], dest[100];
int i;
wmemset(src, L'A', 149);
src[149] = L'\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
dest[99] = L'\0'; 
printWLine(dest);
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
1879,"void function()
{
short data;
data = 0;
while(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
}
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
",0
16706,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
}
}
",1
8132,"void function()
{
int data;
data = -1;
while(1)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
break;
}
while(1)
{
{
int buffer[10] = { 0 };
if (data >= 0)
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is negative"");
}
}
break;
}
}
",0
4778,"void function()
{
int * data;
data = NULL;
if(1)
{
data = (int *)ALLOCA(10);
}
{
int source[10] = {0};
size_t i;
for (i = 0; i < 10; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
}
}
",0
7560,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
badVaSink(data, data);
}
}
",0
5567,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalTrue)
{
wprintf(data);
}
}
",0
10305,"void function()
{
int data;
data = -1;
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
data = 100-1;
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
142,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(STATIC_CONST_TRUE)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
}
}
",0
4040,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
",0
10066,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataGoodBuffer;
data[0] = L'\0'; 
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
}
",1
7534,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(GLOBAL_CONST_TRUE)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
}
}
",0
14123,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",1
6411,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
SNPRINTF(dest, strlen(data), ""%s"", data);
printLine(data);
}
}
",0
14468,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncat(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
22692,"void function()
{
int data;
data = -1;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
11364,"void function()
{
char * data;
data = NULL;
if(1)
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memmove(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
free(data);
}
}
",1
5482,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(GLOBAL_CONST_TRUE)
{
data = dataBuffer - 8;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
1958,"void function()
{
wchar_t * data;
data = NULL;
if(globalTrue)
{
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",0
20047,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
size_t i;
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",1
16889,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
data = dataGoodBuffer;
data[0] = L'\0'; 
break;
}
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
}
}
",1
10387,"void function()
{
char * data;
data = NULL;
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
6949,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100];
data = dataBuffer;
{
char * data = *dataPtr1;
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char dest[50] = """";
memmove(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
}
",0
9721,"void function()
{
wchar_t * data;
data = NULL;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
SNPRINTF(data, 100, L""%s"", source);
printWLine(data);
free(data);
}
}
",1
4572,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
switch(6)
{
case 6:
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",0
16955,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalFive==5)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
20772,"void function()
{
short data;
data = 0;
if(globalReturnsTrue())
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
7736,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
badVaSinkB(data, data);
}
}
",0
4108,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(STATIC_CONST_FIVE==5)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
}
}
",0
6759,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",0
11872,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t dest[50] = L"""";
wcscat(dest, data);
printWLine(data);
}
}
}
",1
6590,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
wprintf(data);
}
}
",0
15262,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
data = dataGoodBuffer;
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memcpy(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
16493,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsTrue())
{
goodB2G2VaSinkG(data, data);
}
}
",1
181,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
switch(6)
{
case 6:
data = dataBadBuffer;
data[0] = '\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncat(data, source, 100);
printLine(data);
}
}
",0
2704,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
goto source;
source:
data = dataBadBuffer;
data[0] = '\0'; 
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",0
20492,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
}
}
",1
18797,"void function()
{
wchar_t * data;
data = NULL;
if(globalTrue)
{
data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
}
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
free(data);
}
}
",1
2877,"void function()
{
char * data;
CWE134_Uncontrolled_Format_String__char_environment_fprintf_34_unionType myUnion;
char dataBuffer[100] = """";
data = dataBuffer;
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
fprintf(stdout, data);
}
}
",0
18312,"void function()
{
int data;
data = -1;
if(5==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
9851,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
size_t i;
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
20573,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
while(1)
{
data = dataGoodBuffer;
break;
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",1
10648,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(staticTrue)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memmove(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
13236,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(5==5)
{
goodG2B1VaSinkB(data, data);
}
}
",1
1812,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
data = dataBadBuffer;
data[0] = '\0'; 
{
char * dataCopy = data;
char * data = dataCopy;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
SNPRINTF(data, 100, ""%s"", source);
printLine(data);
}
}
}
",0
8248,"void function()
{
char * data;
data = NULL;
if(5==5)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",1
14043,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(5==5)
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",1
21536,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(globalReturnsTrue())
{
goodG2B1VaSinkB(data, data);
}
}
",1
6944,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100] = """";
data = dataBuffer;
{
char * data = *dataPtr1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
fprintf(stdout, data);
}
}
",0
22976,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
switch(6)
{
case 6:
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(8)
{
case 7:
printLine(""Benign, fixed string"");
break;
default:
wprintf(L""%s\n"", data);
break;
}
}
",1
7442,"void function()
{
int * data;
CWE122_Heap_Based_Buffer_Overflow__CWE131_memcpy_34_unionType myUnion;
data = NULL;
data = (int *)malloc(10);
if (data == NULL) {exit(-1);}
myUnion.unionFirst = data;
{
int * data = myUnion.unionSecond;
{
int source[10] = {0};
memcpy(data, source, 10*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
}
",0
15823,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(5==5)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
}
}
",1
10977,"void function()
{
int data;
data = -1;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
11983,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalReturnsTrue())
{
data = dataBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
11450,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
data = RAND32();
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
2388,"void function()
{
int i;
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
for(i = 0; i < 1; i++)
{
data = dataBuffer - 8;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",0
12879,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
if(staticFive==5)
{
data = dataGoodBuffer;
}
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
285,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
switch(6)
{
case 6:
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t dest[50] = L"""";
wcsncat(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",0
9234,"void function()
{
int data;
data = -1;
if(5==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(5==5)
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
free(buffer);
}
}
}
",1
13357,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
memcpy(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
12963,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
data = RAND32();
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(8)
{
case 7:
printLine(""Benign, fixed string"");
break;
default:
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
break;
}
}
",1
16861,"void function()
{
if(STATIC_CONST_TRUE)
{
{
char data[150], dest[100];
memset(data, 'A', 149);
data[149] = '\0';
strncpy(dest, data, 99);
dest[99] = '\0'; 
printLine(dest);
}
}
}
",1
9136,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(globalReturnsTrue())
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
818,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(1)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
}
}
",0
21852,"void function()
{
char * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memmove(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
free(data);
}
}
",1
17535,"void function()
{
wchar_t * data;
data = NULL;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
size_t i;
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
486,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticTrue)
{
data = dataBuffer - 8;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",0
10418,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(staticReturnsTrue())
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
7726,"void function()
{
void * data;
data = NULL;
if(GLOBAL_CONST_FIVE==5)
{
{
wchar_t * dataBadBuffer = (wchar_t *)malloc(50*sizeof(wchar_t));
if (dataBadBuffer == NULL) {exit(-1);}
wmemset(dataBadBuffer, L'A', 50-1);
dataBadBuffer[50-1] = L'\0';
data = (void *)dataBadBuffer;
}
}
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = strlen((char *)data);
void * dest = (void *)calloc(dataLen+1, sizeof(wchar_t));
if (dest == NULL) {exit(-1);}
(void)wcscpy(dest, data);
printLine((char *)dest);
free(dest);
}
}
}
",0
1289,"void function()
{
int data;
int *dataPtr1 = &data;
int *dataPtr2 = &data;
data = -1;
{
int data = *dataPtr1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
*dataPtr1 = data;
}
{
int data = *dataPtr2;
{
int buffer[10] = { 0 };
if (data < 10)
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is too big."");
}
}
}
}
",0
6215,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
wprintf(data);
}
}
",0
15613,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
13192,"void function()
{
wchar_t * data;
CWE127_Buffer_Underread__wchar_t_declare_memmove_34_unionType myUnion;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memmove(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
}
",1
21803,"void function()
{
int i,k;
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
for(i = 0; i < 1; i++)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
for(k = 0; k < 1; k++)
{
goodB2GVaSinkG(data, data);
}
}
",1
9804,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
19279,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(staticFive==5)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
}
}
",1
9744,"void function()
{
int h;
wchar_t * data;
data = NULL;
for(h = 0; h < 1; h++)
{
data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
free(data);
}
}
",1
16775,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(staticTrue)
{
goodG2B1VaSinkB(data, data);
}
}
",1
2810,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(globalFive==5)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = strlen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printLine(data);
}
}
",0
3287,"void function()
{
short data;
short *dataPtr1 = &data;
short *dataPtr2 = &data;
data = 0;
{
short data = *dataPtr1;
fscanf (stdin, ""%hd"", &data);
*dataPtr1 = data;
}
{
short data = *dataPtr2;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",0
7866,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
while(1)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
break;
}
while(1)
{
badVaSinkB(data, data);
break;
}
}
",0
9848,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(staticFive==5)
{
wprintf(data);
}
}
",1
9343,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_TRUE)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
8273,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0';
printWLine(data);
}
}
}
",1
8184,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
{
char * dataCopy = data;
char * data = dataCopy;
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
}
}
}
",0
21924,"void function()
{
int64_t * data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
if(GLOBAL_CONST_FIVE==5)
{
data = dataGoodBuffer;
}
{
int64_t source[100] = {0}; 
memcpy(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",1
20843,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
switch(6)
{
case 6:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(8)
{
case 7:
printLine(""Benign, fixed string"");
break;
default:
fwprintf(stdout, L""%s\n"", data);
break;
}
}
",1
18336,"void function()
{
wchar_t * data;
CWE121_Stack_Based_Buffer_Overflow__CWE805_wchar_t_alloca_memmove_34_unionType myUnion;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataGoodBuffer;
data[0] = L'\0'; 
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
}
",1
937,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
5308,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
switch(6)
{
case 6:
data = dataBadBuffer;
data[0] = '\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",0
11689,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
switch(6)
{
case 6:
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char dest[50] = """";
size_t i, dataLen;
dataLen = strlen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
10530,"void function()
{
wchar_t * data;
data = NULL;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
free(data);
}
}
",1
11236,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
goodB2G2VaSinkG(data, data);
}
}
",1
71,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
fscanf(stdin, ""%d"", &data);
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
11201,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_FIVE==5)
{
goodB2G2VaSinkG(data, data);
}
}
",1
5955,"void function()
{
wchar_t * data;
data = NULL;
if(GLOBAL_CONST_TRUE)
{
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",0
1469,"void function()
{
int data;
data = -1;
if(staticFive==5)
{
fscanf(stdin, ""%d"", &data);
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
1656,"void function()
{
int * data;
data = NULL;
if(5==5)
{
data = (int *)malloc(50*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[100] = {0}; 
memcpy(data, source, 100*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",0
15063,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
if(STATIC_CONST_FIVE==5)
{
data = dataGoodBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memcpy(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
14863,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
goto source;
source:
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
{
char dest[50] = """";
memmove(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
4204,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
310,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalFive==5)
{
data = dataBuffer - 8;
}
{
char dest[100*2];
memset(dest, 'C', 100*2-1); 
dest[100*2-1] = '\0'; 
strcpy(dest, data);
printLine(dest);
}
}
",0
18745,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
switch(6)
{
case 6:
data = dataGoodBuffer;
data[0] = '\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",1
12584,"void function()
{
char * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",1
18039,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
goto source;
source:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
goto sink;
sink:
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
",1
11590,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0';
printWLine(data);
}
}
",1
20792,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(1)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
2331,"void function()
{
char * data;
CWE121_Stack_Based_Buffer_Overflow__CWE806_char_alloca_memcpy_34_unionType myUnion;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
{
char dest[50] = """";
memcpy(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
}
",0
1959,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
switch(6)
{
case 6:
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
fwprintf(stdout, data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",0
19929,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(5==5)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(5==5)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
15172,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(STATIC_CONST_FIVE==5)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncat(data, source, 100);
printWLine(data);
}
}
",1
5824,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(GLOBAL_CONST_TRUE)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",0
6989,"void function()
{
int data;
data = -1;
while(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
11145,"void function()
{
int data;
data = -1;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
6663,"void function()
{
int data;
data = -1;
goto source;
source:
data = RAND32();
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
15677,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
12361,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticTrue)
{
wcscpy(data, L""fixedstringtest"");
}
if(staticTrue)
{
wprintf(data);
}
}
",1
20710,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(globalReturnsTrue())
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscat(data, source);
printWLine(data);
}
}
",1
7388,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
goto source;
source:
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
goto sink;
sink:
badVaSinkB(data, data);
}
",0
2643,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(staticReturnsTrue())
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
memmove(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
2322,"void function()
{
int64_t * data;
int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
if(staticFive==5)
{
data = dataBadBuffer;
}
{
int64_t source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printLongLongLine(data[0]);
}
}
}
",0
21941,"void function()
{
short data;
data = 0;
if(1)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
6273,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(1)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memmove(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",0
15080,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
2689,"void function()
{
short data;
data = 0;
if(globalTrue)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = (short)atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
2769,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
{
char dest[100*2];
memset(dest, 'C', 100*2-1); 
dest[100*2-1] = '\0'; 
strcpy(dest, data);
printLine(dest);
}
}
",0
15302,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5==5)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(5==5)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
5655,"void function()
{
char * data;
CWE124_Buffer_Underwrite__char_alloca_ncpy_34_unionType myUnion;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
}
",0
20195,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
}
",1
12903,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
}
}
",1
10439,"void function()
{
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid->voidSecond);
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid->charFirst);
printLine((char *)structCharVoid->voidSecond);
free(structCharVoid);
}
}
}
",1
8640,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(1)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
7009,"void function()
{
int data;
data = -1;
while(1)
{
data = -1;
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
7706,"void function()
{
int * data;
int dataBadBuffer[50];
int dataGoodBuffer[100];
while(1)
{
data = dataBadBuffer;
break;
}
{
int source[100] = {0}; 
memcpy(data, source, 100*sizeof(int));
printIntLine(data[0]);
}
}
",0
12097,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
9891,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
goto source;
source:
data = dataGoodBuffer;
data[0] = '\0'; 
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncat(data, source, 100);
printLine(data);
}
}
",1
10847,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memmove(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
22873,"void function()
{
int data;
data = -1;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
6760,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(staticReturnsTrue())
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
18241,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(STATIC_CONST_TRUE)
{
goodG2B1VaSinkB(data, data);
}
}
",1
11731,"void function()
{
void * data;
data = NULL;
if(GLOBAL_CONST_TRUE)
{
data = (void *)CHAR_STRING;
}
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = strlen((char *)data);
void * dest = (void *)ALLOCA((dataLen+1) * 1);
(void)strcpy(dest, data);
printLine((char *)dest);
}
}
}
",1
21265,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
wcscpy(data, L""fixedstringtest"");
wprintf(data);
}
",1
15123,"void function()
{
int64_t * data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
if(1)
{
data = dataGoodBuffer;
}
{
int64_t source[100] = {0}; 
memcpy(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",1
14258,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalTrue)
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
21569,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
memmove(dest, data, 100*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
22587,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = strlen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printLine(data);
}
}
",1
19147,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
20255,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
",1
4335,"void function()
{
int data;
data = -1;
if(staticTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
7166,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticReturnsTrue())
{
data = dataBuffer - 8;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",0
9868,"void function()
{
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t data[150], dest[100];
wmemset(data, L'A', 149);
data[149] = L'\0';
wcsncpy(dest, data, 99);
dest[99] = L'\0'; 
printWLine(dest);
}
}
}
",1
6188,"void function()
{
int i;
short data;
data = 0;
for(i = 0; i < 1; i++)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
5267,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
data = dataBadBuffer;
data[0] = '\0'; 
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
}
}
",0
19330,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalFive==5)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
17774,"void function()
{
int data;
data = -1;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
9914,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
6329,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(5==5)
{
badVaSinkB(data, data);
}
}
",0
1811,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsTrue())
{
wprintf(data);
}
}
",0
11466,"void function()
{
int data;
data = -1;
if(staticFive==5)
{
fscanf(stdin, ""%d"", &data);
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
20326,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
}
}
",1
17372,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
while(1)
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
break;
}
while(1)
{
fwprintf(stdout, L""%s\n"", data);
break;
}
}
",1
22730,"void function()
{
short data;
data = 0;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
9321,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
goto source;
source:
wcscpy(data, L""fixedstringtest"");
goto sink;
sink:
goodG2BVaSinkB(data, data);
}
",1
808,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
wchar_t * data = *dataPtr1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
badVaSink(data, data);
}
}
",0
11104,"void function()
{
int64_t * data;
data = NULL;
if(GLOBAL_CONST_TRUE)
{
data = (int64_t *)malloc(100*sizeof(int64_t));
if (data == NULL) {exit(-1);}
}
{
int64_t source[100] = {0}; 
memcpy(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
free(data);
}
}
",1
485,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalFive==5)
{
data = dataBuffer - 8;
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",0
15269,"void function()
{
twoIntsStruct * data;
twoIntsStruct dataBadBuffer[50];
twoIntsStruct dataGoodBuffer[100];
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",1
22406,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strncpy(data, source, strlen(source) + 1);
printLine(data);
}
}
",1
1954,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
while(1)
{
data = dataBadBuffer;
data[0] = L'\0'; 
break;
}
{
wchar_t source[10+1] = SRC_STRING;
size_t i, sourceLen;
sourceLen = wcslen(source);
for (i = 0; i < sourceLen + 1; i++)
{
data[i] = source[i];
}
printWLine(data);
}
}
",0
13157,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
while(1)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
break;
}
while(1)
{
fprintf(stdout, ""%s\n"", data);
break;
}
}
",1
21853,"void function()
{
char * data;
data = NULL;
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
16220,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(globalReturnsTrue())
{
goodB2G2VaSinkG(data, data);
}
}
",1
9741,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(staticReturnsTrue())
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
701,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
switch(6)
{
case 6:
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char dest[50] = """";
memmove(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",0
1191,"void function()
{
int data;
data = -1;
if(STATIC_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_TRUE)
{
{
int buffer[10] = { 0 };
if (data < 10)
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is too big."");
}
}
}
}
",0
22896,"void function()
{
if(globalFive==5)
{
{
wchar_t data[150], dest[100];
wmemset(data, L'A', 149);
data[149] = L'\0';
wcsncpy(dest, data, 99);
dest[99] = L'\0'; 
printWLine(dest);
}
}
}
",1
10259,"void function()
{
wchar_t * data;
data = NULL;
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
{
size_t i;
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
",1
1638,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
10281,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
11623,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
data = 100-1;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
1145,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(globalReturnsTrue())
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",0
15092,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(staticFive==5)
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
17799,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(staticFive==5)
{
wprintf(L""%s\n"", data);
}
}
",1
13628,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(1)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
20080,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(GLOBAL_CONST_FIVE==5)
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
5937,"void function()
{
int i;
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
for(i = 0; i < 1; i++)
{
data = dataBuffer - 8;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",0
14267,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
4697,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(staticTrue)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
}
}
",0
9206,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",1
14484,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
printf(""%s\n"", data);
}
}
",1
16458,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
data = dataGoodBuffer;
data[0] = L'\0'; 
break;
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
17229,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(globalReturnsTrue())
{
data = dataGoodBuffer;
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",1
11021,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(staticFive==5)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
}
}
",1
10637,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(staticTrue)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",1
10629,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
fscanf(stdin, ""%d"", &data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
1797,"void function()
{
short data;
data = 0;
if(staticTrue)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = (short)atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
17948,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(STATIC_CONST_TRUE)
{
wprintf(data);
}
}
",1
16479,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFive==5)
{
wcscpy(data, L""fixedstringtest"");
}
if(globalFive==5)
{
goodG2B2VaSinkB(data, data);
}
}
",1
10732,"void function()
{
int data;
int *dataPtr1 = &data;
int *dataPtr2 = &data;
data = -1;
{
int data = *dataPtr1;
data = 100-1;
*dataPtr1 = data;
}
{
int data = *dataPtr2;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",1
4048,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
switch(6)
{
case 6:
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
18653,"void function()
{
int64_t * data;
data = NULL;
if(globalFive==5)
{
data = (int64_t *)malloc(100*sizeof(int64_t));
if (data == NULL) {exit(-1);}
}
{
int64_t source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printLongLongLine(data[0]);
free(data);
}
}
}
",1
6024,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(globalTrue)
{
badVaSinkB(data, data);
}
}
",0
7871,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive==5)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
}
}
",0
15272,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticReturnsTrue())
{
data = dataBuffer;
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0';
printLine(data);
}
}
",1
8320,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
free(data);
}
}
",1
23243,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
12235,"void function()
{
wchar_t * data;
data = NULL;
if(1)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
4568,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
goto source;
source:
data = dataBuffer - 8;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
",0
2140,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5==5)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(5==5)
{
badVaSinkB(data, data);
}
}
",0
10645,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
wprintf(L""%s\n"", data);
}
}
",1
1870,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(staticFive==5)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
13903,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive==5)
{
strcpy(data, ""fixedstringtest"");
}
if(staticFive==5)
{
fprintf(stdout, data);
}
}
",1
4710,"void function()
{
twoIntsStruct * data;
data = NULL;
while(1)
{
data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
break;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printStructLine(&data[0]);
free(data);
}
}
}
",0
1610,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalReturnsTrue())
{
badVaSinkB(data, data);
}
}
",0
14543,"void function()
{
int * data;
int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
if(STATIC_CONST_TRUE)
{
data = dataGoodBuffer;
}
{
int source[100] = {0}; 
memcpy(data, source, 100*sizeof(int));
printIntLine(data[0]);
}
}
",1
17575,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
switch(6)
{
case 6:
data = dataGoodBuffer;
data[0] = L'\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscat(data, source);
printWLine(data);
}
}
",1
10730,"void function()
{
char * data;
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_loop_34_unionType myUnion;
data = NULL;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
}
",1
7194,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
{
char * data = *dataPtr1;
data = dataBadBuffer;
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memmove(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
}
",0
13997,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(STATIC_CONST_FIVE==5)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcat(data, source);
printLine(data);
}
}
",1
6436,"void function()
{
wchar_t * data;
data = NULL;
if(globalTrue)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
}
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",0
6843,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
switch(6)
{
case 6:
data = dataBuffer - 8;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
strncpy(dest, data, strlen(dest));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
11250,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(globalReturnsTrue())
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",1
21006,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
5664,"void function()
{
char * data;
data = NULL;
if(5==5)
{
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
free(data);
}
}
",0
8198,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(staticFive==5)
{
badVaSinkB(data, data);
}
}
",0
3904,"void function()
{
int data;
CWE195_Signed_to_Unsigned_Conversion_Error__connect_socket_strncpy_34_unionType myUnion;
data = -1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
myUnion.unionFirst = data;
{
int data = myUnion.unionSecond;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",0
1267,"void function()
{
if(STATIC_CONST_TRUE)
{
{
charVoid structCharVoid;
structCharVoid.voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid.voidSecond);
memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid.charFirst);
printLine((char *)structCharVoid.voidSecond);
}
}
}
",0
806,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_TRUE)
{
data = RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
21580,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
}
}
",1
19954,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
{
char * dataCopy = data;
char * data = dataCopy;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
}
",1
4274,"void function()
{
char * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memcpy(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
free(data);
}
}
",0
16774,"void function()
{
wchar_t * data;
data = NULL;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
memmove(dest, data, wcslen(dest)*sizeof(wchar_t));
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
}
",1
21317,"void function()
{
char * data;
data = NULL;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
1334,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer - 8;
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t dest[100*2];
wmemset(dest, L'C', 100*2-1); 
dest[100*2-1] = L'\0'; 
wcscpy(dest, data);
printWLine(dest);
}
}
}
",0
10866,"void function()
{
char * data;
data = NULL;
while(1)
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
break;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncat(data, source, 100);
printLine(data);
free(data);
}
}
",1
6971,"void function()
{
int i;
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
for(i = 0; i < 1; i++)
{
data = dataBuffer - 8;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",0
15206,"void function()
{
char * data;
char dataBadBuffer[10];
char dataGoodBuffer[10+1];
if(GLOBAL_CONST_FIVE==5)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",1
950,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
data = RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
4454,"void function()
{
short data;
data = 0;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
15848,"void function()
{
int * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
data = (int *)ALLOCA(10*sizeof(int));
}
{
int source[10] = {0};
memmove(data, source, 10*sizeof(int));
printIntLine(data[0]);
}
}
",1
8867,"void function()
{
void * data;
CWE121_Stack_Based_Buffer_Overflow__CWE135_34_unionType myUnion;
data = NULL;
data = (void *)WIDE_STRING;
myUnion.unionFirst = data;
{
void * data = myUnion.unionSecond;
{
size_t dataLen = wcslen((wchar_t *)data);
void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
(void)wcscpy(dest, data);
printWLine((wchar_t *)dest);
}
}
}
",1
20899,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive==5)
{
wprintf(L""%s\n"", data);
}
}
",1
13778,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
5644,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(globalReturnsTrue())
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",0
16555,"void function()
{
int data;
data = -1;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
19349,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
9292,"void function()
{
char * data;
data = NULL;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
2007,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(STATIC_CONST_FIVE==5)
{
wprintf(data);
}
}
",0
11348,"void function()
{
wchar_t * data;
data = NULL;
if(1)
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
SNPRINTF(data, 100, L""%s"", source);
printWLine(data);
free(data);
}
}
",1
15266,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
switch(6)
{
case 6:
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t dest[50] = L"""";
memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
7467,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
while(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
}
while(1)
{
badVaSinkB(data, data);
break;
}
}
",0
3181,"void function()
{
int i;
char * data;
data = NULL;
for(i = 0; i < 1; i++)
{
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",0
23201,"void function()
{
wchar_t * data;
CWE134_Uncontrolled_Format_String__wchar_t_environment_fprintf_34_unionType myUnion;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
wcscpy(data, L""fixedstringtest"");
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
fwprintf(stdout, data);
}
}
",1
6537,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBadBuffer;
data[0] = L'\0'; 
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
SNPRINTF(data, 100, L""%s"", source);
printWLine(data);
}
}
}
",0
22556,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
}
}
",1
15749,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
wchar_t * data = *dataPtr1;
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
goodB2GVaSink(data, data);
}
}
",1
8520,"void function()
{
int data;
data = -1;
if(staticTrue)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
1579,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(1)
{
data = dataBuffer - 8;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",0
15628,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalReturnsTrue())
{
strcpy(data, ""fixedstringtest"");
}
if(globalReturnsTrue())
{
fprintf(stdout, data);
}
}
",1
257,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(5==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(5==5)
{
badVaSinkB(data, data);
}
}
",0
12494,"void function()
{
int data;
data = -1;
if(staticReturnsTrue())
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
4675,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticFive==5)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",0
13813,"void function()
{
int i,k;
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
for(i = 0; i < 1; i++)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
for(k = 0; k < 1; k++)
{
goodB2GVaSinkG(data, data);
}
}
",1
18478,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
15758,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0';
printWLine(data);
}
}
",1
9069,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(1)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncat(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
11823,"void function()
{
wchar_t * data;
data = NULL;
if(GLOBAL_CONST_TRUE)
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
",1
13081,"void function()
{
int64_t * data;
data = NULL;
if(1)
{
data = (int64_t *)malloc(100*sizeof(int64_t));
if (data == NULL) {exit(-1);}
}
{
int64_t source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printLongLongLine(data[0]);
free(data);
}
}
}
",1
12843,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
goto source;
source:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
goto sink;
sink:
goodB2GVaSinkG(data, data);
}
",1
5611,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
strcpy(dest, data);
printLine(data);
}
}
",0
9791,"void function()
{
void * data;
data = NULL;
if(STATIC_CONST_FIVE==5)
{
data = (void *)WIDE_STRING;
}
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
size_t dataLen = wcslen((wchar_t *)data);
void * dest = (void *)ALLOCA((dataLen+1) * sizeof(wchar_t));
(void)wcscpy(dest, data);
printWLine((wchar_t *)dest);
}
}
}
",1
1713,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(STATIC_CONST_FIVE==5)
{
data = dataBuffer - 8;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",0
19577,"void function()
{
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid->voidSecond);
memcpy(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid->charFirst);
printLine((char *)structCharVoid->voidSecond);
free(structCharVoid);
}
}
}
",1
18126,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(staticTrue)
{
goodG2B1VaSinkB(data, data);
}
}
",1
5138,"void function()
{
int64_t * data;
int64_t * *dataPtr1 = &data;
int64_t * *dataPtr2 = &data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
{
int64_t * data = *dataPtr1;
data = dataBadBuffer;
*dataPtr1 = data;
}
{
int64_t * data = *dataPtr2;
{
int64_t source[100] = {0}; 
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printLongLongLine(data[0]);
}
}
}
}
",0
16656,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(1)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscat(dest, data);
printWLine(data);
free(data);
}
}
",1
17215,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(globalTrue)
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
size_t i, dataLen;
dataLen = wcslen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
21031,"void function()
{
int * data;
data = NULL;
data = (int *)ALLOCA(10*sizeof(int));
{
int source[10] = {0};
memmove(data, source, 10*sizeof(int));
printIntLine(data[0]);
}
}
",1
5588,"void function()
{
char * data;
data = NULL;
if(GLOBAL_CONST_FIVE==5)
{
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",0
20035,"void function()
{
int data;
data = -1;
if(globalTrue)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalTrue)
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
6754,"void function()
{
int data;
data = -1;
if(GLOBAL_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if (data < 100)
{
char * dataBuffer = (char *)malloc(data);
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', data-1);
dataBuffer[data-1] = '\0';
printLine(dataBuffer);
free(dataBuffer);
}
}
",0
20916,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
switch(6)
{
case 6:
wcscpy(data, L""fixedstringtest"");
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
fwprintf(stdout, data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
21866,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(staticTrue)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscat(data, source);
printWLine(data);
}
}
",1
5754,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
printf(data);
}
",0
7146,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
fscanf(stdin, ""%d"", &data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
16986,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive==5)
{
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
14895,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(globalFive==5)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
memmove(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
",1
17042,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(1)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
}
}
",1
11211,"void function()
{
int64_t * data;
int64_t * dataBadBuffer = (int64_t *)ALLOCA(50*sizeof(int64_t));
int64_t * dataGoodBuffer = (int64_t *)ALLOCA(100*sizeof(int64_t));
switch(6)
{
case 6:
data = dataGoodBuffer;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
int64_t source[100] = {0}; 
memmove(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",1
8498,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(staticReturnsTrue())
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",1
18219,"void function()
{
int data;
data = -1;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
2522,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(5==5)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
memcpy(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",0
1034,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
goto source;
source:
data = dataBuffer - 8;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0';
printLine(data);
}
}
",0
21913,"void function()
{
int * data;
data = NULL;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (int *)malloc(100*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[100] = {0}; 
memmove(data, source, 100*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
",1
16139,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
switch(6)
{
case 6:
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t dest[50] = L"""";
size_t i, dataLen;
dataLen = wcslen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
13791,"void function()
{
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
charVoid * structCharVoid = (charVoid *)malloc(sizeof(charVoid));
if (structCharVoid == NULL) {exit(-1);}
structCharVoid->voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid->voidSecond);
memmove(structCharVoid->charFirst, SRC_STR, sizeof(structCharVoid->charFirst));
structCharVoid->charFirst[(sizeof(structCharVoid->charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid->charFirst);
printWLine((wchar_t *)structCharVoid->voidSecond);
}
}
}
",1
19746,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(5==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(5!=5)
{
printLine(""Benign, fixed string"");
}
else
{
printf(""%s\n"", data);
}
}
",1
14237,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
12917,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(8)
{
case 7:
printLine(""Benign, fixed string"");
break;
default:
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
break;
}
}
",1
4708,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(GLOBAL_CONST_TRUE)
{
wprintf(data);
}
}
",0
3023,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(staticFive==5)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",0
23124,"void function()
{
int * data;
CWE122_Heap_Based_Buffer_Overflow__CWE131_memmove_34_unionType myUnion;
data = NULL;
data = (int *)malloc(10*sizeof(int));
if (data == NULL) {exit(-1);}
myUnion.unionFirst = data;
{
int * data = myUnion.unionSecond;
{
int source[10] = {0};
memmove(data, source, 10*sizeof(int));
printIntLine(data[0]);
free(data);
}
}
}
",1
13355,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(GLOBAL_CONST_FIVE==5)
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",1
15859,"void function()
{
short data;
CWE194_Unexpected_Sign_Extension__connect_socket_strncpy_34_unionType myUnion;
data = 0;
data = 100-1;
myUnion.unionFirst = data;
{
short data = myUnion.unionSecond;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",1
22785,"void function()
{
{
charVoid structCharVoid;
structCharVoid.voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid.voidSecond);
memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid.charFirst);
printLine((char *)structCharVoid.voidSecond);
}
}
",1
8385,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticTrue)
{
wcscpy(data, L""fixedstringtest"");
}
if(staticTrue)
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
}
}
",1
10534,"void function()
{
short data;
data = 0;
if(1)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
9065,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
goto source;
source:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
goto sink;
sink:
goodB2GVaSinkG(data, data);
}
",1
15409,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE==5)
{
fscanf(stdin, ""%d"", &data);
}
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
6910,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
12281,"void function()
{
twoIntsStruct * data;
data = NULL;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memcpy(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
free(data);
}
}
",1
14020,"void function()
{
char * data;
data = NULL;
if(GLOBAL_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
19009,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(STATIC_CONST_FIVE==5)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
14007,"void function()
{
char * data;
data = NULL;
if(5==5)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer;
}
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
",1
10474,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
17726,"void function()
{
int data;
data = -1;
if(1)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(1)
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
17947,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(globalFive==5)
{
fprintf(stdout, data);
}
}
",1
19698,"void function()
{
wchar_t * data;
data = NULL;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
free(data);
}
}
",1
11290,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalFive==5)
{
strcpy(data, ""fixedstringtest"");
}
if(globalFive==5)
{
goodG2B2VaSinkB(data, data);
}
}
",1
10766,"void function()
{
wchar_t * data;
CWE124_Buffer_Underwrite__wchar_t_alloca_loop_34_unionType myUnion;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0';
printWLine(data);
}
}
}
",1
6804,"void function()
{
short data;
data = 0;
if(STATIC_CONST_TRUE)
{
data = (short)RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
21630,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
}
}
",1
18366,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(GLOBAL_CONST_FIVE==5)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
}
}
",1
6988,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
while(1)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
break;
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
}
}
",0
18025,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(staticReturnsTrue())
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
1241,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalFive==5)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(globalFive==5)
{
badVaSinkB(data, data);
}
}
",0
19763,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(staticReturnsTrue())
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
free(data);
}
}
",1
5395,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA(50*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
if(globalTrue)
{
data = dataBadBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
}
}
",0
2154,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(globalFive==5)
{
data = dataBuffer - 8;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memcpy(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",0
19995,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
while(1)
{
wcscpy(data, L""fixedstringtest"");
break;
}
while(1)
{
goodG2BVaSinkB(data, data);
break;
}
}
",1
19801,"void function()
{
int data;
data = -1;
if(globalTrue)
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
7877,"void function()
{
twoIntsStruct * data;
twoIntsStruct * *dataPtr1 = &data;
twoIntsStruct * *dataPtr2 = &data;
data = NULL;
{
twoIntsStruct * data = *dataPtr1;
data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
*dataPtr1 = data;
}
{
twoIntsStruct * data = *dataPtr2;
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
free(data);
}
}
}
",0
16357,"void function()
{
short data;
data = 0;
data = 100-1;
{
short dataCopy = data;
short data = dataCopy;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",1
16897,"void function()
{
twoIntsStruct * data;
twoIntsStruct * *dataPtr1 = &data;
twoIntsStruct * *dataPtr2 = &data;
data = NULL;
{
twoIntsStruct * data = *dataPtr1;
data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
*dataPtr1 = data;
}
{
twoIntsStruct * data = *dataPtr2;
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printStructLine(&data[0]);
free(data);
}
}
}
}
",1
8342,"void function()
{
wchar_t * data;
data = NULL;
if(staticReturnsTrue())
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscpy(data, source);
printWLine(data);
free(data);
}
}
",1
14021,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcat(data, source);
printLine(data);
}
}
",1
20354,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcscat(data, source);
printWLine(data);
}
}
",1
4164,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(STATIC_CONST_TRUE)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",0
469,"void function()
{
short data;
data = 0;
if(globalFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
int tempInt;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
tempInt = atoi(inputBuffer);
if (tempInt > SHRT_MAX || tempInt < SHRT_MIN)
{
data = -1;
}
else
{
data = tempInt;
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
5157,"void function()
{
int data;
CWE121_Stack_Based_Buffer_Overflow__CWE129_connect_socket_34_unionType myUnion;
data = -1;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
myUnion.unionFirst = data;
{
int data = myUnion.unionSecond;
{
int i;
int buffer[10] = { 0 };
if (data >= 0)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
}
}
}
",0
16580,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(staticTrue)
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
wcsncpy(data, source, 100-1);
data[100-1] = L'\0';
printWLine(data);
}
}
",1
12495,"void function()
{
int data;
data = -1;
if(staticTrue)
{
data = RAND32();
}
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
11391,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(staticFive==5)
{
fwprintf(stdout, data);
}
}
",1
16112,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
11857,"void function()
{
twoIntsStruct * data;
twoIntsStruct dataBadBuffer[50];
twoIntsStruct dataGoodBuffer[100];
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",1
1104,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
fscanf(stdin, ""%d"", &data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
13888,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
strcpy(data, ""fixedstringtest"");
}
if(STATIC_CONST_FIVE==5)
{
goodG2B2VaSinkB(data, data);
}
}
",1
18664,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
{
size_t dataLen = strlen(data);
char * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
strncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, ""%s"", data);
printLine(dest);
}
}
}
",1
22701,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(globalReturnsTrue())
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
SNPRINTF(dest, strlen(data), ""%s"", data);
printLine(data);
}
}
",1
12381,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
size_t dataLen = wcslen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgetws(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
fclose(pFile);
}
}
}
}
if(STATIC_CONST_FIVE==5)
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
2899,"void function()
{
int i;
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
for(i = 0; i < 1; i++)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
memcpy(dest, data, wcslen(data)*sizeof(wchar_t));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",0
5303,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(STATIC_CONST_TRUE)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_TRUE)
{
fprintf(stdout, data);
}
}
",0
12710,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
}
}
",1
17315,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(GLOBAL_CONST_TRUE)
{
goodG2B1VaSinkB(data, data);
}
}
",1
19126,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
wmemset(dataBadBuffer, L'A', 50-1); 
dataBadBuffer[50-1] = L'\0'; 
wmemset(dataGoodBuffer, L'A', 100-1); 
dataGoodBuffer[100-1] = L'\0'; 
{
wchar_t * data = *dataPtr1;
data = dataGoodBuffer;
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
size_t i, destLen;
wchar_t dest[100];
wmemset(dest, L'C', 100-1);
dest[100-1] = L'\0'; 
destLen = wcslen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = L'\0';
printWLine(dest);
}
}
}
",1
1877,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
{
char * data = *dataPtr1;
data = dataBuffer - 8;
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
{
size_t i;
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
}
",0
12340,"void function()
{
int data;
data = -1;
if(5==5)
{
data = RAND32();
}
if(5==5)
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
6320,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
switch(6)
{
case 6:
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t dest[50] = L"""";
wcsncpy(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",0
7077,"void function()
{
twoIntsStruct * data;
CWE121_Stack_Based_Buffer_Overflow__CWE805_struct_declare_loop_34_unionType myUnion;
twoIntsStruct dataBadBuffer[50];
twoIntsStruct dataGoodBuffer[100];
data = dataBadBuffer;
myUnion.unionFirst = data;
{
twoIntsStruct * data = myUnion.unionSecond;
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printStructLine(&data[0]);
}
}
}
}
",0
940,"void function()
{
twoIntsStruct * data;
twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
while(1)
{
data = dataBadBuffer;
break;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memmove(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",0
11029,"void function()
{
char * data;
data = NULL;
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncat(data, source, 100);
printLine(data);
free(data);
}
}
",1
22629,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcpy(dest, data);
printLine(data);
}
}
",1
16628,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(GLOBAL_CONST_FIVE==5)
{
wcscpy(data, L""fixedstringtest"");
}
if(GLOBAL_CONST_FIVE==5)
{
goodG2B2VaSinkB(data, data);
}
}
",1
9095,"void function()
{
wchar_t * data;
data = NULL;
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = (wchar_t *)malloc((10+1)*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
}
{
wchar_t source[10+1] = SRC_STRING;
memcpy(data, source, (wcslen(source) + 1) * sizeof(wchar_t));
printWLine(data);
free(data);
}
}
",1
9828,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(staticReturnsTrue())
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",1
4019,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
{
wchar_t * data = *dataPtr1;
data = dataBuffer - 8;
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
}
",0
2850,"void function()
{
char * data;
data = NULL;
if(GLOBAL_CONST_TRUE)
{
{
char * dataBuffer = (char *)malloc(100*sizeof(char));
if (dataBuffer == NULL) {exit(-1);}
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
}
}
{
size_t i;
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",0
8139,"void function()
{
int * data;
data = NULL;
if(globalFive==5)
{
data = (int *)ALLOCA(10);
}
{
int source[10] = {0};
size_t i;
for (i = 0; i < 10; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
}
}
",0
21136,"void function()
{
wchar_t * data;
wchar_t * dataBadBuffer = (wchar_t *)ALLOCA((10)*sizeof(wchar_t));
wchar_t * dataGoodBuffer = (wchar_t *)ALLOCA((10+1)*sizeof(wchar_t));
if(STATIC_CONST_TRUE)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
}
}
",1
9947,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(0)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(1)
{
goodG2B1VaSinkB(data, data);
}
}
",1
7050,"void function()
{
if(STATIC_CONST_FIVE==5)
{
{
charVoid structCharVoid;
structCharVoid.voidSecond = (void *)SRC_STR;
printWLine((wchar_t *)structCharVoid.voidSecond);
memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid));
structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(wchar_t))-1] = L'\0'; 
printWLine((wchar_t *)structCharVoid.charFirst);
printWLine((wchar_t *)structCharVoid.voidSecond);
}
}
}
",0
20246,"void function()
{
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
{
charVoid structCharVoid;
structCharVoid.voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid.voidSecond);
memmove(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid.charFirst);
printLine((char *)structCharVoid.voidSecond);
}
}
}
",1
8203,"void function()
{
wchar_t * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",0
9565,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(staticFive==5)
{
data = dataGoodBuffer;
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",1
15767,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticReturnsTrue())
{
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
}
if(staticReturnsTrue())
{
fprintf(stdout, ""%s\n"", data);
}
}
",1
6774,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_FIVE==5)
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
free(buffer);
}
}
}
",0
8606,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
switch(6)
{
case 6:
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
goodB2G2VaSinkG(data, data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
16514,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
strcpy(data, ""fixedstringtest"");
goodG2BVaSink(data, data);
}
",1
5195,"void function()
{
char * data;
data = NULL;
if(STATIC_CONST_TRUE)
{
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",0
2325,"void function()
{
int data;
data = -1;
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
15604,"void function()
{
wchar_t * data;
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncpy(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
15009,"void function()
{
int data;
data = -1;
data = 100-1;
{
int dataCopy = data;
int data = dataCopy;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",1
20406,"void function()
{
twoIntsStruct * data;
data = NULL;
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = (twoIntsStruct *)malloc(100*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printStructLine(&data[0]);
free(data);
}
}
}
",1
20334,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
free(data);
}
}
",1
6931,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE==5)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(STATIC_CONST_FIVE==5)
{
{
int buffer[10] = { 0 };
if (data >= 0)
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is negative"");
}
}
}
}
",0
10638,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(globalTrue)
{
goodG2B1VaSinkB(data, data);
}
}
",1
14334,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
}
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, L""%s"", data);
printWLine(dest);
}
}
}
",1
22966,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(staticFive==5)
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcsncpy(data, source, wcslen(source) + 1);
printWLine(data);
}
}
",1
5208,"void function()
{
wchar_t * data;
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_wchar_t_memmove_34_unionType myUnion;
data = NULL;
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
myUnion.unionFirst = data;
{
wchar_t * data = myUnion.unionSecond;
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
}
",0
22969,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
while(1)
{
strcpy(data, ""fixedstringtest"");
break;
}
while(1)
{
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
break;
}
}
",1
18097,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
data = dataGoodBuffer;
data[0] = '\0'; 
{
char * dataCopy = data;
char * data = dataCopy;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncat(data, source, 100);
printLine(data);
}
}
}
",1
4615,"void function()
{
char * data;
data = NULL;
if(GLOBAL_CONST_FIVE==5)
{
data = (char *)malloc(10*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
free(data);
}
}
",0
20201,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
if(GLOBAL_CONST_TRUE)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
strncpy(dest, data, strlen(data));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
5812,"void function()
{
twoIntsStruct * data;
data = NULL;
if(GLOBAL_CONST_FIVE==5)
{
data = (twoIntsStruct *)malloc(50*sizeof(twoIntsStruct));
if (data == NULL) {exit(-1);}
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
{
size_t i;
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
printStructLine(&data[0]);
free(data);
}
}
}
",0
19989,"void function()
{
int * data;
int dataBadBuffer[50];
int dataGoodBuffer[100];
if(staticFive==5)
{
data = dataGoodBuffer;
}
{
int source[100] = {0}; 
memcpy(data, source, 100*sizeof(int));
printIntLine(data[0]);
}
}
",1
774,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
if(GLOBAL_CONST_FIVE==5)
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",0
15760,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalFalse)
{
printLine(""Benign, fixed string"");
}
else
{
wcscpy(data, L""fixedstringtest"");
}
if(globalTrue)
{
goodG2B1VaSinkB(data, data);
}
}
",1
11111,"void function()
{
int data;
data = -1;
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
22694,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
strcpy(data, ""fixedstringtest"");
}
if(staticFive==5)
{
printf(data);
}
}
",1
4632,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
badVaSink(data, data);
}
",0
266,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
switch(6)
{
case 6:
data = dataBuffer - 8;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
wchar_t dest[100];
wmemset(dest, L'C', 100-1); 
dest[100-1] = L'\0'; 
wcsncpy(dest, data, wcslen(dest));
dest[100-1] = L'\0';
printWLine(dest);
}
}
",0
173,"void function()
{
wchar_t * data;
data = NULL;
while(1)
{
data = (wchar_t *)malloc(50*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
break;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",0
4026,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
data = RAND32();
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
9044,"void function()
{
char * data;
data = NULL;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
{
char * dataCopy = data;
char * data = dataCopy;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
}
",1
14751,"void function()
{
char * data;
data = NULL;
if(1)
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memmove(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
1450,"void function()
{
short data;
short *dataPtr1 = &data;
short *dataPtr2 = &data;
data = 0;
{
short data = *dataPtr1;
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = (short)atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
*dataPtr1 = data;
}
{
short data = *dataPtr2;
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
}
",0
6522,"void function()
{
int64_t * data;
int64_t dataBadBuffer[50];
int64_t dataGoodBuffer[100];
switch(6)
{
case 6:
data = dataBadBuffer;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
int64_t source[100] = {0}; 
memmove(data, source, 100*sizeof(int64_t));
printLongLongLine(data[0]);
}
}
",0
4366,"void function()
{
char * data;
CWE124_Buffer_Underwrite__char_declare_cpy_34_unionType myUnion;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
data = dataBuffer - 8;
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strcpy(data, source);
printLine(data);
}
}
}
",0
17001,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FIVE==5)
{
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
}
if(STATIC_CONST_FIVE!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
20338,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
wcscpy(data, L""fixedstringtest"");
{
wchar_t dest[100] = L"""";
SNPRINTF(dest, 100-1, data);
printWLine(dest);
}
}
",1
3557,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(globalTrue)
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
SNPRINTF(dest, wcslen(data), L""%s"", data);
printWLine(data);
}
}
",0
11510,"void function()
{
int data;
data = -1;
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
9734,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
data = dataGoodBuffer;
data[0] = '\0'; 
{
char * dataCopy = data;
char * data = dataCopy;
{
char source[10+1] = SRC_STRING;
memcpy(data, source, (strlen(source) + 1) * sizeof(char));
printLine(data);
}
}
}
",1
7364,"void function()
{
int data;
data = -1;
if(5==5)
{
fscanf(stdin, ""%d"", &data);
}
if(5==5)
{
{
int buffer[10] = { 0 };
if (data < 10)
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is too big."");
}
}
}
}
",0
9931,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
switch(6)
{
case 6:
{
size_t dataLen = strlen(data);
FILE * pFile;
if (100-dataLen > 1)
{
pFile = fopen(FILENAME, ""r"");
if (pFile != NULL)
{
if (fgets(data+dataLen, (int)(100-dataLen), pFile) == NULL)
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
fclose(pFile);
}
}
}
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(7)
{
case 7:
goodB2G2VaSinkG(data, data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
}
",1
7649,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalTrue)
{
{
size_t dataLen = wcslen(data);
if (100-dataLen > 1)
{
if (fgetws(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = wcslen(data);
if (dataLen > 0 && data[dataLen-1] == L'\n')
{
data[dataLen-1] = L'\0';
}
}
else
{
printLine(""fgetws() failed"");
data[dataLen] = L'\0';
}
}
}
}
if(globalTrue)
{
badVaSinkB(data, data);
}
}
",0
1635,"void function()
{
short data;
data = 0;
data = (short)RAND32();
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memmove(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
18106,"void function()
{
char * data;
char dataBuffer[100];
data = dataBuffer;
while(1)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
break;
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
}
}
",1
12031,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
strcpy(data, ""fixedstringtest"");
{
char * dataCopy = data;
char * data = dataCopy;
{
char dest[100] = """";
SNPRINTF(dest, 100-1, data);
printLine(dest);
}
}
}
",1
20138,"void function()
{
char * data;
data = NULL;
if(staticTrue)
{
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
memcpy(data, source, 100*sizeof(char));
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
",1
20623,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
switch(5)
{
case 6:
printLine(""Benign, fixed string"");
break;
default:
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
break;
}
{
wchar_t dest[50] = L"""";
wcscpy(dest, data);
printWLine(data);
}
}
",1
18254,"void function()
{
int * data;
data = NULL;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = (int *)malloc(10*sizeof(int));
if (data == NULL) {exit(-1);}
}
{
int source[10] = {0};
size_t i;
for (i = 0; i < 10; i++)
{
data[i] = source[i];
}
printIntLine(data[0]);
free(data);
}
}
",1
9148,"void function()
{
char * data;
data = NULL;
if(GLOBAL_CONST_FIVE==5)
{
data = (char *)malloc((10+1)*sizeof(char));
if (data == NULL) {exit(-1);}
}
{
char source[10+1] = SRC_STRING;
strncpy(data, source, strlen(source) + 1);
printLine(data);
free(data);
}
}
",1
14692,"void function()
{
int * data;
int * dataBadBuffer = (int *)ALLOCA(50*sizeof(int));
int * dataGoodBuffer = (int *)ALLOCA(100*sizeof(int));
goto source;
source:
data = dataGoodBuffer;
{
int source[100] = {0}; 
memmove(data, source, 100*sizeof(int));
printIntLine(data[0]);
}
}
",1
20495,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(STATIC_CONST_FIVE==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(STATIC_CONST_FIVE==5)
{
goodB2G2VaSinkG(data, data);
}
}
",1
19010,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
if(1)
{
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
}
{
char dest[50] = """";
size_t i, dataLen;
dataLen = strlen(data);
for (i = 0; i < dataLen; i++)
{
dest[i] = data[i];
}
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
18144,"void function()
{
char * data;
char * *dataPtr1 = &data;
char * *dataPtr2 = &data;
char dataBuffer[100] = """";
data = dataBuffer;
{
char * data = *dataPtr1;
{
size_t dataLen = strlen(data);
if (100-dataLen > 1)
{
if (fgets(data+dataLen, (int)(100-dataLen), stdin) != NULL)
{
dataLen = strlen(data);
if (dataLen > 0 && data[dataLen-1] == '\n')
{
data[dataLen-1] = '\0';
}
}
else
{
printLine(""fgets() failed"");
data[dataLen] = '\0';
}
}
}
*dataPtr1 = data;
}
{
char * data = *dataPtr2;
goodB2GVaSink(data, data);
}
}
",1
16977,"void function()
{
int data;
data = -1;
switch(6)
{
case 6:
fscanf(stdin, ""%d"", &data);
break;
default:
printLine(""Benign, fixed string"");
break;
}
switch(8)
{
case 7:
printLine(""Benign, fixed string"");
break;
default:
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
break;
}
}
",1
18585,"void function()
{
wchar_t * data;
data = NULL;
while(1)
{
data = (wchar_t *)malloc(100*sizeof(wchar_t));
if (data == NULL) {exit(-1);}
data[0] = L'\0'; 
break;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0'; 
printWLine(data);
free(data);
}
}
",1
2243,"void function()
{
wchar_t * data;
wchar_t * *dataPtr1 = &data;
wchar_t * *dataPtr2 = &data;
wchar_t dataBuffer[100];
data = dataBuffer;
{
wchar_t * data = *dataPtr1;
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
*dataPtr1 = data;
}
{
wchar_t * data = *dataPtr2;
{
wchar_t dest[50] = L"""";
wcsncpy(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
}
",0
11761,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(globalReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(globalReturnsTrue())
{
fwprintf(stdout, L""%s\n"", data);
}
}
",1
8579,"void function()
{
char * data;
char dataBuffer[100] = """";
data = dataBuffer;
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
char *replace;
SOCKET listenSocket = INVALID_SOCKET;
SOCKET acceptSocket = INVALID_SOCKET;
size_t dataLen = strlen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
listenSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (listenSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = INADDR_ANY;
service.sin_port = htons(TCP_PORT);
if (bind(listenSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
if (listen(listenSocket, LISTEN_BACKLOG) == SOCKET_ERROR)
{
break;
}
acceptSocket = accept(listenSocket, NULL, NULL);
if (acceptSocket == SOCKET_ERROR)
{
break;
}
recvResult = recv(acceptSocket, (char *)(data + dataLen), sizeof(char) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(char)] = '\0';
replace = strchr(data, '\r');
if (replace)
{
*replace = '\0';
}
replace = strchr(data, '\n');
if (replace)
{
*replace = '\0';
}
}
while (0);
if (listenSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(listenSocket);
}
if (acceptSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(acceptSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
{
char * dataCopy = data;
char * data = dataCopy;
fprintf(stdout, ""%s\n"", data);
}
}
",1
1067,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
data = dataBuffer;
if(staticReturnsTrue())
{
wmemset(data, L'A', 100-1); 
data[100-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
SNPRINTF(dest, wcslen(data), L""%s"", data);
printWLine(data);
}
}
",0
2241,"void function()
{
int data;
data = -1;
if(globalReturnsTrue())
{
data = RAND32();
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
strncpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
22472,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
if(staticFalse)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncpy(data, source, 100-1);
data[100-1] = '\0';
printLine(data);
}
}
",1
455,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
if(globalReturnsTrue())
{
data = dataBadBuffer;
data[0] = '\0'; 
}
{
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
strncat(data, source, 100);
printLine(data);
}
}
",0
13595,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100];
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
if(STATIC_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataBuffer;
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memcpy(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
20056,"void function()
{
while(1)
{
{
charVoid structCharVoid;
structCharVoid.voidSecond = (void *)SRC_STR;
printLine((char *)structCharVoid.voidSecond);
memcpy(structCharVoid.charFirst, SRC_STR, sizeof(structCharVoid.charFirst));
structCharVoid.charFirst[(sizeof(structCharVoid.charFirst)/sizeof(char))-1] = '\0'; 
printLine((char *)structCharVoid.charFirst);
printLine((char *)structCharVoid.voidSecond);
}
break;
}
}
",1
18528,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
switch(6)
{
case 6:
data = dataGoodBuffer;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
memcpy(dest, data, strlen(dest)*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
17227,"void function()
{
int data;
data = -1;
if(staticFive==5)
{
fscanf(stdin, ""%d"", &data);
}
if(staticFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
{
int i;
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
4537,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
{
size_t dataLen = wcslen(data);
wchar_t * environment = GETENV(ENV_VARIABLE);
if (environment != NULL)
{
wcsncat(data+dataLen, environment, 100-dataLen-1);
}
}
{
wchar_t * dataCopy = data;
wchar_t * data = dataCopy;
badVaSink(data, data);
}
}
",0
13800,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
goto source;
source:
data = dataGoodBuffer;
data[0] = L'\0'; 
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
}
}
",1
4816,"void function()
{
int data;
data = -1;
if(staticFive==5)
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
SOCKET connectSocket = INVALID_SOCKET;
char inputBuffer[CHAR_ARRAY_SIZE];
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, inputBuffer, CHAR_ARRAY_SIZE - 1, 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
inputBuffer[recvResult] = '\0';
data = atoi(inputBuffer);
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticFive==5)
{
{
int i;
int * buffer = (int *)malloc(10 * sizeof(int));
if (buffer == NULL) {exit(-1);}
for (i = 0; i < 10; i++)
{
buffer[i] = 0;
}
if (data >= 0)
{
buffer[data] = 1;
for(i = 0; i < 10; i++)
{
printIntLine(buffer[i]);
}
}
else
{
printLine(""ERROR: Array index is negative."");
}
free(buffer);
}
}
}
",0
13327,"void function()
{
char * data;
char dataBuffer[100];
memset(dataBuffer, 'A', 100-1);
dataBuffer[100-1] = '\0';
switch(6)
{
case 6:
data = dataBuffer;
break;
default:
printLine(""Benign, fixed string"");
break;
}
{
char dest[100];
memset(dest, 'C', 100-1); 
dest[100-1] = '\0'; 
memmove(dest, data, 100*sizeof(char));
dest[100-1] = '\0';
printLine(dest);
}
}
",1
7222,"void function()
{
char * data;
CWE122_Heap_Based_Buffer_Overflow__c_CWE805_char_loop_34_unionType myUnion;
data = NULL;
data = (char *)malloc(50*sizeof(char));
if (data == NULL) {exit(-1);}
data[0] = '\0'; 
myUnion.unionFirst = data;
{
char * data = myUnion.unionSecond;
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
free(data);
}
}
}
",0
1378,"void function()
{
char * data;
data = (char *)malloc(100*sizeof(char));
if (data == NULL) {exit(-1);}
if(globalTrue)
{
memset(data, 'A', 100-1); 
data[100-1] = '\0'; 
}
{
char dest[50] = """";
strcat(dest, data);
printLine(data);
free(data);
}
}
",0
13449,"void function()
{
wchar_t * data;
wchar_t dataBuffer[100] = L"""";
data = dataBuffer;
if(staticReturnsTrue())
{
{
WSADATA wsaData;
int wsaDataInit = 0;
int recvResult;
struct sockaddr_in service;
wchar_t *replace;
SOCKET connectSocket = INVALID_SOCKET;
size_t dataLen = wcslen(data);
do
{
if (WSAStartup(MAKEWORD(2,2), &wsaData) != NO_ERROR)
{
break;
}
wsaDataInit = 1;
connectSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
if (connectSocket == INVALID_SOCKET)
{
break;
}
memset(&service, 0, sizeof(service));
service.sin_family = AF_INET;
service.sin_addr.s_addr = inet_addr(IP_ADDRESS);
service.sin_port = htons(TCP_PORT);
if (connect(connectSocket, (struct sockaddr*)&service, sizeof(service)) == SOCKET_ERROR)
{
break;
}
recvResult = recv(connectSocket, (char *)(data + dataLen), sizeof(wchar_t) * (100 - dataLen - 1), 0);
if (recvResult == SOCKET_ERROR || recvResult == 0)
{
break;
}
data[dataLen + recvResult / sizeof(wchar_t)] = L'\0';
replace = wcschr(data, L'\r');
if (replace)
{
*replace = L'\0';
}
replace = wcschr(data, L'\n');
if (replace)
{
*replace = L'\0';
}
}
while (0);
if (connectSocket != INVALID_SOCKET)
{
CLOSE_SOCKET(connectSocket);
}
if (wsaDataInit)
{
WSACleanup();
}
}
}
if(staticReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
goodB2G1VaSinkG(data, data);
}
}
",1
12247,"void function()
{
wchar_t * data;
wchar_t * dataBuffer = (wchar_t *)ALLOCA(100*sizeof(wchar_t));
data = dataBuffer;
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
wmemset(data, L'A', 50-1); 
data[50-1] = L'\0'; 
}
{
wchar_t dest[50] = L"""";
wcsncat(dest, data, wcslen(data));
dest[50-1] = L'\0'; 
printWLine(data);
}
}
",1
6328,"void function()
{
twoIntsStruct * data;
twoIntsStruct * dataBadBuffer = (twoIntsStruct *)ALLOCA(50*sizeof(twoIntsStruct));
twoIntsStruct * dataGoodBuffer = (twoIntsStruct *)ALLOCA(100*sizeof(twoIntsStruct));
while(1)
{
data = dataBadBuffer;
break;
}
{
twoIntsStruct source[100];
{
size_t i;
for (i = 0; i < 100; i++)
{
source[i].intOne = 0;
source[i].intTwo = 0;
}
}
memcpy(data, source, 100*sizeof(twoIntsStruct));
printStructLine(&data[0]);
}
}
",0
16763,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA((10)*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA((10+1)*sizeof(char));
data = dataGoodBuffer;
data[0] = '\0'; 
{
char * dataCopy = data;
char * data = dataCopy;
{
char source[10+1] = SRC_STRING;
strcpy(data, source);
printLine(data);
}
}
}
",1
12509,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[10];
wchar_t dataGoodBuffer[10+1];
if(GLOBAL_CONST_FALSE)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
wchar_t source[10+1] = SRC_STRING;
wcscpy(data, source);
printWLine(data);
}
}
",1
15320,"void function()
{
int data;
data = -1;
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
data = 100-1;
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",1
13352,"void function()
{
char * data;
char * dataBadBuffer = (char *)ALLOCA(50*sizeof(char));
char * dataGoodBuffer = (char *)ALLOCA(100*sizeof(char));
memset(dataBadBuffer, 'A', 50-1); 
dataBadBuffer[50-1] = '\0'; 
memset(dataGoodBuffer, 'A', 100-1); 
dataGoodBuffer[100-1] = '\0'; 
if(STATIC_CONST_TRUE)
{
data = dataGoodBuffer;
}
{
size_t i, destLen;
char dest[100];
memset(dest, 'C', 100-1);
dest[100-1] = '\0'; 
destLen = strlen(dest);
for (i = 0; i < destLen; i++)
{
dest[i] = data[i];
}
dest[100-1] = '\0';
printLine(dest);
}
}
",1
22821,"void function()
{
char * data;
char * dataBuffer = (char *)ALLOCA(100*sizeof(char));
data = dataBuffer;
goto source;
source:
memset(data, 'A', 50-1); 
data[50-1] = '\0'; 
{
char dest[50] = """";
memcpy(dest, data, strlen(data)*sizeof(char));
dest[50-1] = '\0'; 
printLine(data);
}
}
",1
20928,"void function()
{
int data;
data = -1;
if(staticTrue)
{
fscanf(stdin, ""%d"", &data);
}
if(staticTrue)
{
{
int buffer[10] = { 0 };
if (data >= 0 && data < (10))
{
printIntLine(buffer[data]);
}
else
{
printLine(""ERROR: Array index is out-of-bounds"");
}
}
}
}
",1
19612,"void function()
{
if(globalReturnsFalse())
{
printLine(""Benign, fixed string"");
}
else
{
{
char src[150], dest[100];
int i;
memset(src, 'A', 149);
src[149] = '\0';
for(i=0; i < 99; i++)
{
dest[i] = src[i];
}
dest[99] = '\0'; 
printLine(dest);
}
}
}
",1
7263,"void function()
{
char * data;
char dataBadBuffer[50];
char dataGoodBuffer[100];
data = dataBadBuffer;
data[0] = '\0'; 
{
size_t i;
char source[100];
memset(source, 'C', 100-1); 
source[100-1] = '\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = '\0'; 
printLine(data);
}
}
",0
4175,"void function()
{
int data;
data = -1;
{
char inputBuffer[CHAR_ARRAY_SIZE] = """";
if (fgets(inputBuffer, CHAR_ARRAY_SIZE, stdin) != NULL)
{
data = atoi(inputBuffer);
}
else
{
printLine(""fgets() failed."");
}
}
{
char source[100];
char dest[100] = """";
memset(source, 'A', 100-1);
source[100-1] = '\0';
if (data < 100)
{
memcpy(dest, source, data);
dest[data] = '\0'; 
}
printLine(dest);
}
}
",0
19172,"void function()
{
wchar_t * data;
wchar_t dataBadBuffer[50];
wchar_t dataGoodBuffer[100];
if(globalFive!=5)
{
printLine(""Benign, fixed string"");
}
else
{
data = dataGoodBuffer;
data[0] = L'\0'; 
}
{
size_t i;
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
for (i = 0; i < 100; i++)
{
data[i] = source[i];
}
data[100-1] = L'\0'; 
printWLine(data);
}
}
",1
16949,"void function()
{
wchar_t * data;
data = NULL;
if(globalTrue)
{
{
wchar_t * dataBuffer = (wchar_t *)malloc(100*sizeof(wchar_t));
if (dataBuffer == NULL) {exit(-1);}
wmemset(dataBuffer, L'A', 100-1);
dataBuffer[100-1] = L'\0';
data = dataBuffer;
}
}
{
wchar_t source[100];
wmemset(source, L'C', 100-1); 
source[100-1] = L'\0'; 
memmove(data, source, 100*sizeof(wchar_t));
data[100-1] = L'\0';
printWLine(data);
}
}
",1
